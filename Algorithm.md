- [[#난이도 下|난이도 下]]
	- [[#난이도 下#문자열 조합|문자열 조합]]
	- [[#난이도 下#dfs|dfs]]
	- [[#난이도 下#bfs|bfs]]
	- [[#난이도 下#시뮬레이션|시뮬레이션]]
	- [[#난이도 下#투포인터|투포인터]]
	- [[#난이도 下#이분탐색|이분탐색]]
- [[#난이도 中|난이도 中]]
	- [[#난이도 中#위상정렬|위상정렬]]
		- [[#위상정렬#1. 기초|1. 기초]]
		- [[#위상정렬#2. 경로 역추적|2. 경로 역추적]]
	- [[#난이도 中#최소 신장 트리 (MST)|최소 신장 트리 (MST)]]
	- [[#난이도 中#크루스칼|크루스칼]]
		- [[#크루스칼#1. 이행적 폐쇄 (Transitive Closure)|1. 이행적 폐쇄 (Transitive Closure)]]
		- [[#크루스칼#2. 최소 비용 (Floyd-Warshall Algorithm)|2. 최소 비용 (Floyd-Warshall Algorithm)]]
	- [[#난이도 中#프림|프림]]
	- [[#난이도 中#그리디|그리디]]
	- [[#난이도 中#백트래킹|백트래킹]]
- [[#난이도 上|난이도 上]]
	- [[#난이도 上#동적 프로그래밍|동적 프로그래밍]]
	- [[#난이도 上#트라이, KMP|트라이, KMP]]
	- [[#난이도 上#다익스트라|다익스트라]]


## 난이도 下
---
### 문자열 조합



---
### dfs




---
### bfs

- 큐의 size를 센 뒤 그만큼만 빼면 depth마다 따로 모아서 탐색할 수 있다. ([코드](https://lazyartisan.tistory.com/48))


---
### 시뮬레이션

- 시뮬레이션도 큐를 활용하면 필요한 부분만 갱신할 수 있다 ([코드](https://lazyartisan.tistory.com/50)) - 사실 문제 자체는 시뮬레이션으로 분류가 안돼있긴 함. 내가 억지로 시뮬레이션으로 풀었던 거.


---
### 투포인터


---
### 이분탐색


---


## 난이도 中
---
### 위상정렬

#### 1. 기초

사이클이 없는 단방향 그래프면 일단 위상 정렬 의심하기.

간선 하나 탐색해서 뽑아버릴 때마다 indegree 하나씩 빼주고,
indegree가 0이 되면 그제야 해당 정점에서 갈 수 있는 다음 정점을 탐색한다.

쉽게 말하여, "**들어올 수 있는 간선 다 찾았으면 다음으로 보낸다.**"

근데 재귀로 역탐색하면 해당 도착지까지 필요한 경로를 위상 정렬과 똑같이 구할 수 있음.
이렇게 하는게 더 간단. ([코드](https://lazyartisan.tistory.com/51))
모든 정점에 대해 순서를 지켜서 출력해야되는거면 역탐색 재귀 쓰면 안됨.

#### 2. 경로 역추적

경로 역추적 (임계경로 문제) : [코드](https://lazyartisan.tistory.com/52)

---
### 최소 신장 트리 (MST)



---
### 크루스칼

삼중 for문으로 모든 정점을 순회하면서  
"나 거쳐서 갈 수 있는 놈들 있어? 싹 다 갱신해봐"

가 플로이드 와샬 알고리즘이다.

#### 1. 이행적 폐쇄 (Transitive Closure)

비용 상관없이 갈 수 있느냐 없느냐만 따져보면

```
for k in range(n):  # 나 A를 거쳐서
    for i in range(n):  # B 너가
        for j in range(n):  # C로 갈 수 있니?
            if closure[i][k] and closure[k][j]:
                closure[i][j] = True
```

첫번째 for문 요소 : "나 A를 거쳐서"  
두번째 for문 요소 : "B 너가"  
세번째 for문 요소 : "C로 갈 수 있니?"

"나 A를 거쳐서, B 너가, C로 갈 수 있니?"

#### 2. 최소 비용 (Floyd-Warshall Algorithm)

최소 비용 버전으로 보면

```
for k in range(n):  # 나 A를 거쳐서 가는게
    for i in range(n):  # B 너가
        for j in range(n):  # C로 갈 때 더 빨리 가니?
            if dist[i][j] > dist[i][k] + dist[k][j]:
                dist[i][j] = dist[i][k] + dist[k][j]
```

첫번째 for문 요소 : "나 A를 거쳐서 가는게"  
두번째 for문 요소 : "B 너가"  
세번째 for문 요소 : "C로 갈 때 더 빨리 가니?"

"나 A를 거쳐서 가는게, B 너가, C로 갈 때 더 빨리 가니?"

---
### 프림



---
### 그리디



---
### 백트래킹



---

## 난이도 上
---
### 동적 프로그래밍


---
### 트라이, KMP


---
### 다익스트라




