- [[#📌 팁|📌 팁]]
	- [[#📌 팁#단축키|단축키]]
	- [[#📌 팁#에디터|에디터]]
- [[#✂️ 스니펫|✂️ 스니펫]]
	- [[#✂️ 스니펫#2D 랜덤 방향|2D 랜덤 방향]]
	- [[#✂️ 스니펫#싱글톤|싱글톤]]
	- [[#✂️ 스니펫#Player Input|Player Input]]
- [[#⚙️ 설정|⚙️ 설정]]
	- [[#⚙️ 설정#🏷️ 성능|🏷️ 성능]]
		- [[#🏷️ 성능#수정 후 빠르게 재생|수정 후 빠르게 재생]]
	- [[#⚙️ 설정#🏷️ 디버그|🏷️ 디버그]]
		- [[#🏷️ 디버그#애셋 직렬화 방식 통일|애셋 직렬화 방식 통일]]
		- [[#🏷️ 디버그#프로젝트 렌더링 파이프라인 확인|프로젝트 렌더링 파이프라인 확인]]
- [[#💾 개념|💾 개념]]
	- [[#💾 개념#🏷️ General|🏷️ General]]
		- [[#🏷️ General#.meta 파일|.meta 파일]]
		- [[#🏷️ General#Assembly Definition (asmdef)|Assembly Definition (asmdef)]]
	- [[#💾 개념#🏷️ Script|🏷️ Script]]
		- [[#🏷️ Script#재정의(override) 가능한 메서드|재정의(override) 가능한 메서드]]
		- [[#🏷️ Script#Unity : Coroutine|Unity : Coroutine]]
		- [[#🏷️ Script#Managed Object|Managed Object]]
- [[#📖 Manual|📖 Manual]]
	- [[#📖 Manual#🏷️ Component|🏷️ Component]]
		- [[#🏷️ Component#Rigidbody|Rigidbody]]
			- [[#Rigidbody#Body Type|Body Type]]
		- [[#🏷️ Component#CharacterController|CharacterController]]
		- [[#🏷️ Component#Mesh Renderer|Mesh Renderer]]
		- [[#🏷️ Component#Cinemachine|Cinemachine]]
			- [[#Cinemachine#Aim|Aim]]
		- [[#🏷️ Component#Line Renderer|Line Renderer]]
	- [[#📖 Manual#🏷️ Script|🏷️ Script]]
	- [[#📖 Manual#Rect Transform|Rect Transform]]
		- [[#Rect Transform#OnRenderImage()|OnRenderImage()]]
		- [[#Rect Transform#`OnAudioFilterRead(float[] data, int channels)`|`OnAudioFilterRead(float[] data, int channels)`]]
		- [[#Rect Transform#`[ImageEffectOpaque]`|`[ImageEffectOpaque]`]]
		- [[#Rect Transform#Graphics.Blit()|Graphics.Blit()]]
	- [[#📖 Manual#🏷️ UI|🏷️ UI]]
		- [[#🏷️ UI#Scroll View|Scroll View]]
	- [[#📖 Manual#🏷️ Shader Graph|🏷️ Shader Graph]]
		- [[#🏷️ Shader Graph#노드|노드]]
	- [[#📖 Manual#🏷️ Settings|🏷️ Settings]]
		- [[#🏷️ Settings#오클루전 컬링 활성화하는 법|오클루전 컬링 활성화하는 법]]
- [[#📄 Detail|📄 Detail]]
	- [[#📄 Detail#🏷️ Editor|🏷️ Editor]]
		- [[#🏷️ Editor#Import|Import]]
		- [[#🏷️ Editor#커서 어케 바꿈|커서 어케 바꿈]]
	- [[#📄 Detail#🏷️ Script|🏷️ Script]]
		- [[#🏷️ Script#GetKey 차이|GetKey 차이]]
		- [[#🏷️ Script#GetAxis, GetAxisRaw 차이|GetAxis, GetAxisRaw 차이]]
		- [[#🏷️ Script#private void vs void|private void vs void]]
		- [[#🏷️ Script#변수를 꼭 밖으로 뺄 이유는 없다|변수를 꼭 밖으로 뺄 이유는 없다]]
	- [[#📄 Detail#🏷️ Physics|🏷️ Physics]]
		- [[#🏷️ Physics#Collision|Collision]]
		- [[#🏷️ Physics#Trigger|Trigger]]
	- [[#📄 Detail#🏷️ Graphic|🏷️ Graphic]]
		- [[#🏷️ Graphic#Image vs Raw Image|Image vs Raw Image]]
		- [[#🏷️ Graphic#모델 노말 계산 설정|모델 노말 계산 설정]]
	- [[#📄 Detail#🏷️ Component|🏷️ Component]]
		- [[#🏷️ Component#Animation Rigging|Animation Rigging]]
	- [[#📄 Detail#🏷️ Animation|🏷️ Animation]]
- [[#🛠️ Editor Script|🛠️ Editor Script]]
- [[#💻 CSharp|💻 CSharp]]
	- [[#💻 CSharp#🏷️ 구문|🏷️ 구문]]
		- [[#🏷️ 구문#`using` (네임스페이스 x)|`using` (네임스페이스 x)]]
	- [[#💻 CSharp#🏷️ 접근 제한자|🏷️ 접근 제한자]]
		- [[#🏷️ 접근 제한자#internal|internal]]
	- [[#💻 CSharp#🏷️ 특성(Attribute)|🏷️ 특성(Attribute)]]
		- [[#🏷️ 특성(Attribute)#`[StructLayout()]`|`[StructLayout()]`]]
- [[#📦 애셋 사용법|📦 애셋 사용법]]
	- [[#📦 애셋 사용법#Analytic Volumetric Light|Analytic Volumetric Light]]
	- [[#📦 애셋 사용법#VRoid|VRoid]]
- [[#🦫 디버깅|🦫 디버깅]]
	- [[#🦫 디버깅#🏷️ Editor|🏷️ Editor]]
		- [[#🏷️ Editor#Tile Pallete 타일 크기 작음|Tile Pallete 타일 크기 작음]]
		- [[#🏷️ Editor#라이트에 쿠키 넣고 텍스쳐 타입 바꿨더니 조명 꺼짐|라이트에 쿠키 넣고 텍스쳐 타입 바꿨더니 조명 꺼짐]]
		- [[#🏷️ Editor#Render Texture 크기 변경 안됨|Render Texture 크기 변경 안됨]]
		- [[#🏷️ Editor#Package Export 종속성만 체크가 안됨|Package Export 종속성만 체크가 안됨]]
		- [[#🏷️ Editor#PSD import가 안됨|PSD import가 안됨]]
		- [[#🏷️ Editor#SRP Batcher가 없음|SRP Batcher가 없음]]
	- [[#🦫 디버깅#🏷️ 인게임|🏷️ 인게임]]
		- [[#🏷️ 인게임#📌 Collision 관련|📌 Collision 관련]]
		- [[#🏷️ 인게임#오브젝트들 전부 살짝 흐림|오브젝트들 전부 살짝 흐림]]
		- [[#🏷️ 인게임#Cinemachine 따라가기 덜덜 떨림|Cinemachine 따라가기 덜덜 떨림]]
		- [[#🏷️ 인게임#콜라이더 적용해도 벽뚫|콜라이더 적용해도 벽뚫]]
		- [[#🏷️ 인게임#플레이어가 벽에 달라붙음|플레이어가 벽에 달라붙음]]
		- [[#🏷️ 인게임#플레이어가 벽에 닿으면 계속 점프 가능함|플레이어가 벽에 닿으면 계속 점프 가능함]]
		- [[#🏷️ 인게임#Navmesh Bake 안 보임|Navmesh Bake 안 보임]]
		- [[#🏷️ 인게임#Raycast 안됨|Raycast 안됨]]
		- [[#🏷️ 인게임#머테리얼을 Transparent로 설정해도 살짝 불투명|머테리얼을 Transparent로 설정해도 살짝 불투명]]
		- [[#🏷️ 인게임#플레이어 이동에 약간 딜레이|플레이어 이동에 약간 딜레이]]
		- [[#🏷️ 인게임#스프라이트 마스크 어떻게 씀?|스프라이트 마스크 어떻게 씀?]]
		- [[#🏷️ 인게임#Camera.main이 null임|Camera.main이 null임]]
		- [[#🏷️ 인게임#DontDestroyOnLoad() 해도 사라짐|DontDestroyOnLoad() 해도 사라짐]]
		- [[#🏷️ 인게임#콜라이더가 분명 하나인데 더 달려있음|콜라이더가 분명 하나인데 더 달려있음]]
		- [[#🏷️ 인게임#Rigidbody 중력 작용 안 함|Rigidbody 중력 작용 안 함]]
		- [[#🏷️ 인게임#sorting layer 바꿨더니 검은색 됨|sorting layer 바꿨더니 검은색 됨]]
		- [[#🏷️ 인게임#위치 순간이동 로직 짰는데 순간이동 안 함|위치 순간이동 로직 짰는데 순간이동 안 함]]
	- [[#🦫 디버깅#fbx export 했는데 blender에서 인식 안돼|fbx export 했는데 blender에서 인식 안돼]]
	- [[#🦫 디버깅#🏷️ 스크립트|🏷️ 스크립트]]
		- [[#🏷️ 스크립트#using Cinemachine이 안 먹힘|using Cinemachine이 안 먹힘]]
		- [[#🏷️ 스크립트#Trigger가 안됨|Trigger가 안됨]]
		- [[#🏷️ 스크립트#print()가 안됨|print()가 안됨]]
	- [[#🦫 디버깅#🏷️ Shader Graph|🏷️ Shader Graph]]
		- [[#🏷️ Shader Graph#2D Sprite Texture 연결했는데 전부 단색으로 나옴|2D Sprite Texture 연결했는데 전부 단색으로 나옴]]
	- [[#🦫 디버깅#🏷️ UI|🏷️ UI]]
		- [[#🏷️ UI#9-slice 적용 안됨|9-slice 적용 안됨]]
	- [[#🦫 디버깅#🏷️ 협업|🏷️ 협업]]
		- [[#🏷️ 협업#깃 pull 할 때마다 메타파일 갱신|깃 pull 할 때마다 메타파일 갱신]]
- [[#🚀 최적화|🚀 최적화]]
	- [[#🚀 최적화#유나이트 서울 2020 - 최대 성능을 위한 최적화 팁|유나이트 서울 2020 - 최대 성능을 위한 최적화 팁]]
		- [[#유나이트 서울 2020 - 최대 성능을 위한 최적화 팁#플랫폼별 적절한 Tris(폴리곤) 개수 가이드라인|플랫폼별 적절한 Tris(폴리곤) 개수 가이드라인]]
		- [[#유나이트 서울 2020 - 최대 성능을 위한 최적화 팁#씬 내 폴리곤 최적화|씬 내 폴리곤 최적화]]



## 📌 팁
---

- 씬 뷰 좌측 상단 Global을 Local로 바꾸면 해당 오브젝트이 rotation한 대로 축이 변경됨
- 추노마크 없애기 : Project Settings > Player > Splash Image > Show Splash Screen
- [debug 쉽게 하기](https://github.com/JohnBaracuda/com.baracuda.runtime-monitoring?tab=readme-ov-file) 
  - Asset Store에서 등록해놨으니 PackageManager에서 설치
  - Tools에서 세팅하기 
  - `using Baracuda.Monitoring;` 
  - 인스턴스는 시작할 때 `this.StartMonitoring()`
- Unity 엔진 내부에서는 **값이 실제로 바뀔 때**만 C++ 레이어로 내려가서 `Renderer::SetEnabled()`  등 프로퍼티를 호출

### 단축키

- 창 전체화면 : Shift + Space
- 카메라, 조명 등을 씬 뷰 시선에 맞추기 : 선택하고 Ctrl+Sfhit+F

### 에디터
- 프리팹 옆에 있는 화살표 누르면 프리팹 편집기로 바로 들어갈 수 있다.

## ✂️ 스니펫
---

### 2D 랜덤 방향

```cs
Random.insideUnitCircle.normalized
```

### 싱글톤

```cs
using UnityEngine;

public class Singleton<T> : MonoBehaviour where T : MonoBehaviour
{
    public static T Instance { get; private set; }

    protected virtual void Awake()
    {
        if (Instance == null)
        {
            Instance = this as T;
        }
        else if (Instance != this)
        {
            Destroy(gameObject);
        }
    }
}
```

### Player Input

```cs
public class PlayerMove : MonoBehaviour
{
    [SerializeField] float moveSpeed;
    [SerializeField] InputActionReference inputAction;
    CharacterController cc;

    void Start()
    {
        cc = GetComponent<CharacterController>();
    }

    void Update()
    {
        Vector2 moveInput = inputAction.action.ReadValue<Vector2>();
        Vector3 moveDirection = new Vector3(moveInput.x, 0, moveInput.y).normalized;
        cc.Move(moveDirection * moveSpeed * Time.deltaTime);
    }
}
```


## ⚙️ 설정
---

### 🏷️ 성능

#### 수정 후 빠르게 재생
Edit → Project Settings → Editor → Enter Play Mode Options


### 🏷️ 디버그

#### 애셋 직렬화 방식 통일
Edit - Project Settings - Editor - Asset Serialization - Force Text로 바꾸기

#### 프로젝트 렌더링 파이프라인 확인
Edit - Project Settings - Graphics - Scriptable Pipeline Settings 확인



## 💾 개념
---

### 🏷️ General
#### .meta 파일
컴포넌트 간의 연결과 같은 메타 정보들을 담고 있다.
유니티 에디터에서 파일 위치나 이름 바꾼거 아니면 이거 때문에 정보 소실.

깃허브에 커밋할 때 .meta 빠뜨리면 안되고
외부에 깃 말고 보낼 땐 .unitypackage로 만들어라.

#### Assembly Definition (asmdef)
- 기본적으로 Unity 프로젝트의 모든 C# 스크립트는 UnityEngine.dll에 하나로 컴파일한다.
- 이때 `.asmdef` 파일을 추가하면 해당 폴더와 하위 폴더의 스크립트들을 별도의 어셈블리로 컴파일하게 만들 수 있다.
- 근데 의존성을 일일이 추가해줘야 한다. 불편하긴 하지만 의존성 관리에 용이.

### 🏷️ Script
#### 재정의(override) 가능한 메서드
- 부모 클래스의 메서드가 `virtual`, `abstract`, 또는 `override`로 선언되지 않았다면, 자식 클래스에서 해당 메서드를 `override`로 재정의할 수 없습니다.
- Unity의 `Awake`는 기본적으로 MonoBehaviour의 메서드로 `virtual`이 아니므로, 재정의하려면 부모 클래스에서 `Awake`를 `virtual`로 명시해야 합니다.

#### Unity : Coroutine

**개념 및 원리**
- 설정한 만큼 멈췄다가 다시 실행
- 멈췄던 위치에서 다시 실행됨
- 긴 비동기 작업할 때 쓰면 됨
- 멀티쓰레딩은 아니다

**문제 및 해결**
- 디버깅 어렵다. 로그 넣어주자.
- 다 쓰고 안 꺼주면 성능 문제.
- 무거운 연산 쓰면 프레임 드랍. 프레임마다 쪼개서 실행하기.

**끄는 법**
- StopCoroutine(), StopAllCoroutines()
- 코루틴 붙은 오브젝트 SetActive(false), Destroy()
- Monobehaviour 스크립트는 enabled false로 해도 코루틴 안 꺼짐

#### Managed Object
- .NET 런타임(예: CLR, Common Language Runtime)의 관리 아래 존재하는 객체
- 메모리 할당, 해제, 가비지 컬렉션 같은 작업을 자동 관리
- 예
  - new로 만든 C# 객체들 (예: new MyClass())
  - Unity의 MonoBehaviour, ScriptableObject 같은 컴포넌트 객체들
  - 배열, 리스트, 딕셔너리 등 .NET 기본 자료구조들
- 이거 쓰면 Burst Compiler 못 씀


## 📖 Manual
---

### 🏷️ Component

#### Rigidbody
##### Body Type
- Dynamic : 완전히 물리 연산
- Kinematic : 물리 연산 없이 충돌 감지만 가능. 움직이려면 rb.MovePosition()
- Static : 절대 안 움직임
#### CharacterController
- 정확한 충돌 감지 (벽 통과 방지)  
- 중력, 계단 이동, 경사면 처리 가능  
- Rigidbody 없이도 이동 및 점프 구현 가능  
- 플레이어 이동을 세밀하게 조정 가능  
- 물리 연산이 불필요하여 성능 최적화 가능 

#### Mesh Renderer
- 기본 역할: 정적(Static) 또는 변형되지 않는 3D 메시에 대한 렌더링을 처리.
- 사용 예시: 건물, 바위, 가구 등 변형되지 않는 오브젝트.
- 특징:
  - Transform 컴포넌트로 위치, 회전, 크기만 변경 가능.
  - 메시의 정점(Vertex)이나 형태가 바뀌지 않음.
  - 단순한 렌더링 파이프라인을 사용하며, 계산량이 적음.
  - 머티리얼 및 셰이더와 호환성이 높음.
#### Cinemachine
##### Aim
1. Do nothing  : 카메라가 대상을 바라보지 않고, 별도의 조정 없이 고정된 상태로 유지됩니다.
2. Composer : 자동으로 목표 오브젝트를 따라가며 화면에서 적절한 위치에 유지되도록 합니다. 카메라가 부드럽게 따라가는 효과가 있습니다.
3. Group Composer : 여러 개의 대상을 포함하는 그룹을 추적하는 기능입니다. 그룹 내 대상의 위치를 조정하여 카메라가 자연스럽게 움직이도록 합니다.
4. Hard Look At : 카메라가 항상 목표 오브젝트를 정확하게 바라보도록 강제하는 방식입니다. 회전이 즉각적으로 적용되며 자연스러운 움직임 없이 즉시 방향을 맞춥니다.
5. POV : 1인칭 혹은 3인칭 조작 방식에서 사용되며, 플레이어 입력(마우스 또는 컨트롤러)을 기반으로 카메라가 회전합니다. FPS(1인칭 슈팅 게임) 또는 TPS(3인칭 액션 게임) 카메라에서 많이 사용됩니다.
6. Same As Follow Target : 카메라가 설정된 대상의 회전을 그대로 따라갑니다.

#### Line Renderer
Scene Tools : 점 세개 누르면 점 옮기기
Positions : 정점 추가
중앙 빨간 선 : 폭 조절
Conrner Vertices : 모서리 둥글기
End Cap Vertices : 끝점 둥글기

### 🏷️ Script

### Rect Transform
- RectTransform.rect는 Scale With Screen Size일 때 Reference Resolution을 반환
- Camera.WorldToScreenPoint()는 특정 월드 좌표의 스크린 좌표계를 반환
- Camera.WorldToViewportPoint()는 특정 월드 좌표의 뷰포트 좌표계를 반환
- rect transform의 anchor가 범위라면 부모 오브젝트(캔버스도 포함)를 상대적 비율로 덮음
- anchor의 y를 각각 0과 1로 두면 width만 조절하면 알아서 화면 꽉 채워줌
- UI 요소 크기 공식 : actualSize = (anchorMax - anchorMin) * 부모크기 + sizeDelta

#### OnRenderImage()
- 카메라 포스트 프로세싱에 사용되는 함수
- Unity 카메라가 씬을 렌더링한 직후에 호출됨
- 렌더링된 결과(`source`)를 받아서 필터/이펙트 처리 후 `destination`에 출력하는 구조
- 이 함수가 호출되려면, 스크립트가 카메라에 붙어 있어야 하고, 
  해당 카메라에 depthTextureMode 또는 PostProcess 관련 설정이 있어야 함.

#### `OnAudioFilterRead(float[] data, int channels)`
- 오디오 처리할 때 콜백 함수. 
- data에 샘플들 담겨있다. (샘플 : 소리 크기 숫자, 이것들을 다 이으면 오디오 된다.)
- 채널 2개면 data에 번갈아가며 저장돼있다.
- 메인 쓰레드와 별개의 쓰레드에서 호출된다.

#### `[ImageEffectOpaque]`
- 렌더 순서를 opaque 렌더링 이후(transparent 이전)로 설정

#### Graphics.Blit()
- Blit = Bit Block Transfer : 텍스처를 복사하거나 가공해서 다른 텍스쳐로 넘기는 함수
- `Graphics.Blit(source, destination);` : source 이미지를 destination으로 그냥 복사
- `Graphics.Blit(source, destination, _Material);` : _Material에 연결된 셰이더를 사용해서 source를 처리한 뒤 destination에 씀


### 🏷️ UI

#### Scroll View
- Content에 element들을 전부 넣는다
- Content에 Vertical Layout Group 추가 > Child Alignment 조정
- Content에 Content Size Fitter 추가 > Vertical Fit Preferred Size
- 그래도 안되면 Viewport > Scroll Rect> Content > Content 할당

### 🏷️ Shader Graph

#### 노드
- Scanline 효과: Checkerboard

### 🏷️ Settings

#### 오클루전 컬링 활성화하는 법
- Occluder Static이나 Occludee Static 체크하고
- Window > Rendering > Occlusion Culling > Bake
- Scene View의 Visualisation 탭 활성화하여 미리 보기


## 📄 Detail
---
### 🏷️ Editor

- 오브젝트들 묶었을 때 피벗은 부모 오브젝트의 위치

#### Import
- 블랜더 export할 때 : Selected Objects, Apply Transform (유니티 원치않는 회전 막기)
- 유니티로 import할 때
	- Model > import 붙은 옵션 끄기
	- Model > Scale Factor 조절하여 크기 조절
	- Material Creation Mode > None
	- Animation > Import Animation 끄기

- 모델의 크기는 성능에 영향 안 주고, 버텍스와 폴리곤 개수가 성능에 영향 미친다

#### 커서 어케 바꿈
Project Settings - Player - Default Cursor

### 🏷️ Script

#### GetKey 차이
GetKey : 해당 키 누르는 동안 true 반복적 반환  
GetKeyDown : 해당 키 누르면 단 한 번 true 반환  
GetKeyUp : 해당 키 누름 해제되면 true 한 번 반환

#### GetAxis, GetAxisRaw 차이
Input.GetAxis() : 사용자가 키를 누르면 값이 0에서 1로 서서히 증가하며, 키를 떼면 1에서 0으로 서서히 감소합니다.
Input.GetAxisRaw() : 키를 누르는 순간 1이 되고, 키를 떼면 즉시 0으로 돌아갑니다.
#### private void vs void
접근 제한자는 생략해도 되지만 가독성을 위해 명시적으로 추가하는게 좋다.

#### 변수를 꼭 밖으로 뺄 이유는 없다
```cs
void Update()
{
	GameObject player = GameObject.FindWithTag("Player");
}
```

player를 update 문 바깥에서 전역 변수로 선언한다고 해서 메모리가 아껴지진 않는다. 
어차피 update 문이 끝나면 스택 메모리가 자동으로 정리되기 때문이다.

### 🏷️ Physics

#### Collision
- OnCollisionEnter는 Rigidbody가 있는 최상위 부모 오브젝트 기준으로 collision 가져옴
- OnCollisionEnter에선 linearVelocity 0되므로 relativeVelocity 써야 함
- 둘 중 하나라도 트리거 체크돼있으면 CollisionEnter 작동 안 함
- `collision.collider`은 상대방 콜라이더를 의미한다

#### Trigger
- OnTriggerEnter는 정확히 닿은 오브젝트 기준으로 collider 가져옴
- rigidbody continous 설정해도 고속 물체 감지 불가
- TriggerEnter(Collider col)에서 굳이 col.gameObject.CompareTag()할 필요 없이 col.CompareTag()


### 🏷️ Graphic

#### Image vs Raw Image
- Image는 UI 디자인 요소에 적합하며, 간단하고 효율적으로 사용 가능합니다.
- Raw Image는 동적 콘텐츠나 렌더 텍스처를 처리하거나, 셰이더 효과를 적용할 때 적합합니다.

#### 모델 노말 계산 설정
model import settings에서 Normals를 Calculate로 바꾸고
Smoothing Angle을 조절하면 폴리곤 단위에 가깝게 노말 계산


### 🏷️ Component

#### Animation Rigging

- 런타임에 굳이 Target 바꾸지 말고 Target의 Transform을 바꿔라.

### 🏷️ Animation

- 모델을 클릭해야 Animation Clip을 수정할 수 있다
- Animator Controller에서 새 레이어로 BlendShape override 가능하다
- Animator Clip에서 스크롤바 늘려놔서 한꺼번에 보이게 하기


## 🛠️ Editor Script
---

UnityEditor namespace를 추가하고 EditorWindow를 상속받은 후 `[MenuItem("Window/메뉴 이름")]` 이 특성을 static 메서드 앞에 붙이면 지정한 메뉴 클릭 시 해당 메서드 호출






## 💻 CSharp
---

### 🏷️ 구문

#### `using` (네임스페이스 x)

```cs
using (var resource = new SomeResource())
{
    // 이 블록 안에서 resource 사용
}
// 블록 끝나면 resource.Dispose() 자동 호출됨
```

`IDisposable` 인터페이스를 구현한 객체의 `Dispose()` 메서드를 자동으로 호출해주는 구문.
GC가 못 닫는 파일 핸들, 네트워크 소켓, 네이티브 메모리 같은 거 자동으로 `Dispose()`해준다.

### 🏷️ 접근 제한자
#### internal
private 같은 접근 제한자의 일종.
해당 코드(클래스, 메서드, 필드 등)가 같은 어셈블리 안에서만 접근 가능하도록 만듦.
Burst 컴파일하면 using으로 자동 Dispose 호출 안 해준다.


### 🏷️ 특성(Attribute)
#### `[StructLayout()]`
- .NET 런타임에서 구조체나 클래스의 메모리 배치를 지정할 때 사용
- `StructLayout(LayoutKind.Sequential)` : 필드를 선언한 순서대로 메모리에 배치하라




## 📦 애셋 사용법
---
### Analytic Volumetric Light

초기 설정 제대로 다 했는데도 제대로 안 보임 : Global Volume에 추가한 override에서 Air Density 다 켜지 말 것

Base Light를 설정한 후에 원본 빛을 바꿨다면 Copy From Light Component


### VRoid

vrm importer : https://github.com/vrm-c/UniVRM
- v0.129.0은 오류 발생, v0.128.3 사용.

눈 깜빡임 : [https://gist.github.com/AISebas/cc799c262ff71cd7d1e92f0dd7e5e5fb](https://gist.github.com/AISebas/cc799c262ff71cd7d1e92f0dd7e5e5fb)  
눈 따라가기 : VRMInstance > select UI > LookAt

**믹사모 애니메이션 적용 방법**
- unity package manager > Unity Registry > fbx exporter 설치
- 모델을 씬에 올린 뒤 export fbx (안되면 fbx exporter 재설치)
- 믹사모에 fbx 파일 올린 뒤에 애니메이션 다운 받기
- 믹사모 파일 가져온 뒤 Rig > Animation Type > Humanoid
- 가져온 파일에서 애니메이션 클립만 따로 복사
- 애니메이션 클립 루트 모션 관련 필요한대로 설정

**표정 제어**
Fcl_All 계열은 VRM10Instance에서 덮어씌워버린다.
그 이외 파라미터들은 애니메이터로 제어 가능하다.

1. UniVRM의 기능을 이용하지 않을 거라면
Update Type을 None으로 두고 Animator로만 제어한다.

2. UniVRM 무시하고 계속 덮어씌우기
애니메이션 클립에서 키프레임을 하나 더 생성해서 애니메이션이 계속 재생되게 만들면 UniVRM의 덮어씌우기가 무시된다.

3. UniVRM의 Expression API 사용하기
- import했던 VRM 모델로 간다
- VRM 탭 > Extract Meta And Expressions
```cs
using UnityEngine;
using UniVRM10;

public class ChangeExpression : MonoBehaviour
{
    Vrm10Instance vrm;
    public ExpressionKey smile;

    void Start()
    {
        vrm = GetComponent<Vrm10Instance>();
        smile = ExpressionKey.CreateFromPreset(ExpressionPreset.happy);
    }

    void Update()
    {
        vrm.Runtime.Expression.SetWeight(smile, 1);
    }
}
```



**워크플로 비교**

| 항목                   | VRM → FBX 변환 후 사용                             | UniVRM 그대로 사용                                                                 |
| -------------------- | --------------------------------------------- | ----------------------------------------------------------------------------- |
| 리깅/애니메이션         | Unity Humanoid 리깅 자동 감지 → Animator 사용. 문제 없음. | 동일. 다만 VRM 표정(BlendShape)·눈동자 시선 제어가 이미 세팅됨.                                  |
| 표정 · BlendShape  | 변환 시 클립 이름·순서가 흐트러질 수 있어 수동 재매핑 필요.           | `VRMBlendShapeProxy`가 웃음/슬픔/놀람 등 표준 슬롯을 유지. 바로 Playable API·Timeline에서 호출 가능. |
| 헤어/치마 물리         | Dynamic Bone·Unity Physics 등을 직접 붙여야 함.       | `VRMSpringBone`이 메타데이터 기반으로 즉시 동작.                                            |
| 메타데이터 (작가, 라이선스) | FBX에는 안 남음 → 별도 관리 필요.                        | `VRMMeta` 컴포넌트에 포함(저작자·라이선스·연령등급).                                            |
| 런타임 아바타 교체       | Addressables 혹은 애셋번들 직접 제작 필요.                | `VRMImporterContext.LoadAsync(byte[])` 하나로 외부 VRM 파일 로드 가능.                   |
| 빌드 크기·성능         | 컴포넌트 수가 적어 약간 가벼움.                            | 스크립트·컴포넌트 추가(≈ 20 ~ 50 KB, 무시 가능).                                            |
| 유지보수             | 표준 FBX 파이프라인 → 아티스트·툴 전환 쉬움.                  | UniVRM 업데이트(0.x → 1.x) 따라가야 함.                                                |
| VR/소셜 지원         | 직접 구현.                                        | VCI / VRM 1.0 규격과 호환.                                                         |

**UniVRM가 해주는 일**

| 컴포넌트                                          | 역할                                                   |
| --------------------------------------------- | ---------------------------------------------------- |
| `VRMHumanoidDescription`                      | IK 입력(목·눈·손) → Humanoid Rig 매핑 자동화                   |
| `VRMBlendShapeProxy`                          | 52 종 표준 BlendShape 슬롯 + 커스텀 클립 제어 API 제공             |
| `VRMSpringBone`, `VRMSpringBoneColliderGroup` | 머리카락·치마 물리(간단 반‑객체 동역학)                              |
| `VRMLookAtHead`, `VRMLookAtBoneApplyer`       | 카메라·타깃을 향해 눈/목 회전                                    |
| `VRMFirstPerson`                              | VR / 1인칭 렌더링 시 머리 숨김, 눈 깊이 클립 오프셋                    |
| `VRMMeta`                                     | Title, Author, Contact, License(商用/改変/再配布) 등 json 추출 |

| VRM 0.x                | VRM 1.0                                |
| ---------------------- | -------------------------------------- |
| **VRMBlendShapeProxy** | **`Vrm10Instance.Runtime.Expression`** |
| VRMLookAt              | `Vrm10Instance.Runtime.LookAt`         |
| VRMSpringBone          | `Vrm10Instance.Runtime.SpringBone`     |




## 🦫 디버깅
---

### 🏷️ Editor

#### Tile Pallete 타일 크기 작음
Tile Pallete 만들 때 Cell Size 1x1로 설정

#### 라이트에 쿠키 넣고 텍스쳐 타입 바꿨더니 조명 꺼짐
넣었던 쿠키 삭제했다가 다시 넣으면 켜질거임

#### Render Texture 크기 변경 안됨
Enable Compatible Format 체크 해제하고 바꿔보셈

#### Package Export 종속성만 체크가 안됨
Include all 체크 해제

#### PSD import가 안됨
Texture의 Inspector 상단에서 Importer를 PSD Importer로 바꾸셈

#### SRP Batcher가 없음
URP Asset > Rendering > 우측 상단 점 세개


### 🏷️ 인게임

#### 📌 Collision 관련

- OnTriggerEnter()는 Rigidbody를 Continous로 설정해도 고속 물체 감지 불가
- 둘 중 하나라도 Is Trigger 체크돼있으면 OnCollisionEnter() 작동 안 함
- OnCollisionEnter()에선 linearVelocity 대신 relativeVelocity 써야 함. 
  linearVelocity는 충돌 때문에 0됨. 
  relativeVelocity 쓸 땐 rb가 아니라 collision에서 가져와야 함.



#### 오브젝트들 전부 살짝 흐림
해상도를 Full HD로 바꾸고 1.5x로 돼있는 Scale을 1x로 바꾸기

#### Cinemachine 따라가기 덜덜 떨림
- Rigidbody > Interpolation > Interpolate로 변경
- Cinemachine Brain > Blend Update Method > Fixed Update

#### 콜라이더 적용해도 벽뚫
Rigidbody > Collision Detection > Continous로 변경

#### 플레이어가 벽에 달라붙음
Physics Material 2D > Friction 0 > 적용

#### 플레이어가 벽에 닿으면 계속 점프 가능함
캡슐 콜라이더 아래에 점프 가능여부 확인하는 작은 네모 콜라이더 만들면 됨

#### Navmesh Bake 안 보임
- Bake 하는 방법을 못 찾겠음 : Navmesh Surface 추가
- Bake 했는데 안 보임 : 우측 하단 AI Navigation > Surfaces > Show Navmesh 체크

#### Raycast 안됨
- 2D 프로젝트면 Physics2D.Raycast() 사용하기
- 렌더 텍스쳐를 Output Texture에 넣으면 마우스 Raycast 작동 안 함. 셰이더 쓰셈.

#### 머테리얼을 Transparent로 설정해도 살짝 불투명
셰이더를 Unlit으로 설정한다

#### 플레이어 이동에 약간 딜레이
Input.GetAxis 쓰면 딜레이 생긴다. Input.GetAxisRaw 쓰기.

#### 스프라이트 마스크 어떻게 씀?
Sprite Mask component may not be an issue. 
check Mask Interaction component on parent.

#### Camera.main이 null임
`Camera.main`은 "MainCamera" 태그가 붙은 카메라만 인식

#### DontDestroyOnLoad() 해도 사라짐
부모를 없애

#### 콜라이더가 분명 하나인데 더 달려있음
Character Controller에도 collider 달려있어서 그럼
굳이 콜라이더 추가할 필요 없음

#### Rigidbody 중력 작용 안 함
Character Controller 붙어있으면 Rigidbody 적용 안됨
`controller.Move(velocity * Time.deltaTime);` 이걸로 중력 구현하셈

#### sorting layer 바꿨더니 검은색 됨
global light 2d는 target sorting layer가 있어서 그걸 벗어나면 비춰주지 않는다

#### 위치 순간이동 로직 짰는데 순간이동 안 함
Character Controller는 내부 상태 유지 때문에 순간이동 무시함
순간이동 시킬 땐 enabled false 했다가 이동시키고 true하면 됨

### fbx export 했는데 blender에서 인식 안돼
export format을 binary로 바꿔

### 🏷️ 스크립트

#### using Cinemachine이 안 먹힘
using Unity.Cinemachine 쓰셈

#### Trigger가 안됨
rigidbody 붙이셈

#### print()가 안됨
그거 MonoBehaviour랑 ScriptableObject에서만 됨.
대신 Debug.log() 쓰셈
내 코드 중에 Debug라는 이름 가진 클래스 있어도 안됨.

### 🏷️ Shader Graph

#### 2D Sprite Texture 연결했는데 전부 단색으로 나옴
Alpha 값도 연결하셈


### 🏷️ UI
#### 9-slice 적용 안됨
UI element의 Image - Image Type을 sliced로 바꾼다

### 🏷️ 협업
#### 깃 pull 할 때마다 메타파일 갱신
1. 애셋 직렬화 방식 : Project Settings - Editor - Asset Serialization - Force Text 통일
2. Project Settings - Editor - Version Control - Visible Meta Files 통일



## 🚀 최적화

- 퀄리티 차이 안 날 때까지 Texture의 Max Size 줄이기
- 중요하지 않은 물체는 Scale in Lightmap 줄이기

### 유나이트 서울 2020 - 최대 성능을 위한 최적화 팁

https://www.youtube.com/watch?v=tT9LS53HRx4

Script
- Object Pooling 써라
- 게임에서 변하지 않는 데이터를 위한 클래스 작성할 때 MonoBehaviour 말고 Scriptable Object 써라
- 프로퍼티 대신 그냥 변수 써라. 프로퍼티 사용하면 함수 호출하는 거라 특히 Update()같은 곳에서 잦은 호출할 때 안 좋다.
- Resources 폴더에 있는 리소스 많으면 앱 준비 시간에 나쁜 영향 준다. 가능하면 Addressable Assets 패키지의 AssetBundle 써라.
- Start()나 Update()같은 Unity 이벤트 함수는 비어 있으면 지워라. 비어있어도 선언돼있으면 매번 호출된다. 컴포넌트까지 같이 불려오기 때문에 느려진다.
  - release에선 별다른 구현 없지만 디버깅 용으로 사용한다면 define 분기로 최종 빌드에선 제외되게 해라.
- Awake(), Start()가 무거우면 Scene() 초기 동작을 지연시킨다. 초기화 로직 무거우면 Update()에서 별도의 FSM으로 초기화 구간을 구성해라.
- Hierarchy 복잡성 줄여라. Transform 구조들은 배열로 저장돼서 수정할 때마다 모든 배열 값 재설정. 가급적 Hiearchy 구조 변경도 하지 말기.
  - 계층적 구조가 필요한게 아니라면 Root에 GameObject를 배치하는게 성능면에서 가장 좋다.
- Find()는 모든 GameObject에 대해, GetComponent(), GetComponentInChildren()은 GameObject 내의 모든 컴포넌트에 대해 검사를 수행한다. 가능하면 미리 초기화 시점에 캐싱해둬라.
  - 검사 대상도 많고, 비교 검사 자체가 문자열 조건을 비교해서 오버헤드가 높다. 자주 사용하지 마라.

Texture Import Settings
- Generate Mipmaps : 밉맵 안 쓰면 꺼라. 리소스 용량 24% 감소.
- Format : (대부분은 자동으로 잘 압축) 디바이스에서 지원하는 압축 포맷 선택해야 무압축 대비 1/4 감소.
- 불필요한 알파 채널 삭제한다. 이미지 퀄리티 손실 조금 감소시켜줌.
- Read/Write Enable 해제한다. (기본값도 해제)

Mesh Import Settings
  - Mesh Compression : 원본과 안 달라지는 선에서 최대한 높은 압축 선택. Runtime 메모리는 영향 없지만 패키지 용량 감소.
  - Read/Write Enabled, Blendshapes, Normals and Tangents, Rig 등 사용 안하면 다 꺼라.

Audio Import Settings
- 스테레오 꼭 필요한 거 아니면 Force to Mono 사용
- 퀄리티 손상 체크하며 Compression bitrate 낮추기
- Audio Clip 크기 별 Load Type
  - 200kb 미만 : Decompress On Load
  - 200kb 이상 : Compressed In Memory
  - 1mb 이상 : Streaming
- Mute (볼륨 0) 상태에선 오디오 재생을 중지해라. 그리고 필요 없어지면 Audio Clip Unload해라.

Batching
  - 가능하면 같은 Texture / Material 써서 Batching 성공률 높여라. 아니면 Atlas Texture 써라.
  - Dynamic Batching 했는데 Batching 성공률 낮으면 그냥 꺼라.

Light
- 그림자 필요 없는 오브젝트는 Cast Shadow 꺼라.
- Light 효과 받는 대상은 별도 Layer로 구성해서 Culling Mask로 계산 비용 최소한으로 해라. Light(특히 Spot Light)는 계산 비용이 높다. 
- 보이지 않는 UI는 Activate 끄거나 Hide해라 . 카메라 밖으로 벗어나거나 다른 UI에 가려져도 실제로는 매 프레임마다 렌더링된다.

UI
- 정적인 UI와 동적인 UI를 분리시켜라. UI 변경 시 발생하는 UI Mesh 재생성 최소화할 수 있다.
- 하나의 Canvas에 있는 UI의 Z값을 동일하게 설정해라. Z값 다르면 Batching이 깨진다.
- Atlas를 활용하여 같은 머테리얼과 텍스쳐를 쓰게 해라.
- 동일한 Clipping Rect를 사용해라.
- 입력 이벤트 필요없으면 Graphic Raycaster 꺼라.
- Pause나 Main menu 띄울 때 전체 화면 불투명으로 가리는 UI 써라. Camera도 꺼서 렌더링 비용 줄여라.
- Frame Rate 낮춰라.

#### 플랫폼별 적절한 Tris(폴리곤) 개수 가이드라인  

| 플랫폼                                 | 권장 Tris 개수 (씬 전체 기준) | 최적화 필요 여부                 |
| ----------------------------------- | -------------------- | ------------------------- |
| 모바일 (Low-end, 보급형 기기)               | 100K ~ 300K          | ✅ 필수 (LOD + Occlusion)    |
| 모바일 (High-end, 플래그십 기기)             | 300K ~ 700K          | ⚠️ 일부 최적화 필요              |
| PC (Low-end, 내장그래픽, GTX 750 이하)     | 500K ~ 1M (100만)     | ✅ 필요 (LOD + Draw Call 감소) |
| PC (중급, GTX 1060 ~ 1660)            | 1M ~ 2M (200만)       | ⚠️ 적당한 최적화 필요             |
| PC (고급, RTX 3060 이상)                | 2M ~ 5M (500만)       | ❌ 최적화 크게 필요 없음            |
| PS4 / Xbox One                      | 1M ~ 2M (200만)       | ⚠️ 일부 최적화 필요              |
| PS5 / Xbox Series X                 | 3M ~ 10M (천만)        | ❌ 높은 처리 가능                |
| VR (Standalone, Quest 2)            | 100K ~ 500K          | ✅ 필수 (프레임 유지 필수)          |
| VR (PC VR, Valve Index, Quest Link) | 1M ~ 3M (300만)       | ⚠️ 약간의 최적화 필요             |

#### 씬 내 폴리곤 최적화

1️⃣ LOD(Level of Detail) 활용  
   - 가까운 오브젝트만 고해상도, 멀리 있는 건 저해상도로 자동 변경  
   - `LOD Group`을 활용해서 LOD 0 (높은 Tris) → LOD 3 (낮은 Tris) 설정

2️⃣ Occlusion Culling 활성화  
   - 카메라에 안 보이는 모델을 렌더링하지 않도록 최적화  
   - `Window > Rendering > Occlusion Culling`에서 적용

3️⃣ Batches / Draw Calls 최적화  
   - `Stats` 창에서 `SetPass Calls`가 많으면 병목 가능성 있음  
   - Mesh Combine + GPU Instancing을 적용해서 성능 개선

4️⃣ Shader & Material 최적화  
   - PBR 쉐이더 사용을 줄이고, Lightmap 사용으로 실시간 조명 연산을 줄이기  
   - 한 개의 머티리얼을 여러 개의 오브젝트에서 공유하면 드로우콜 감소

5️⃣ Dynamic Objects 줄이기  
   - 애니메이션이 적용된 오브젝트가 많으면 CPU 부하 증가  
   - `Static Batching`을 적용하면 정적인 오브젝트를 최적화할 수 있음



