- [[#📌 팁|📌 팁]]
	- [[#📌 팁#단축키|단축키]]
	- [[#📌 팁#에디터|에디터]]
- [[#✂️ 스니펫|✂️ 스니펫]]
	- [[#✂️ 스니펫#2D 랜덤 방향|2D 랜덤 방향]]
	- [[#✂️ 스니펫#싱글톤|싱글톤]]
	- [[#✂️ 스니펫#Player Input|Player Input]]
- [[#⚙️ 설정|⚙️ 설정]]
	- [[#⚙️ 설정#🏷️ 성능|🏷️ 성능]]
		- [[#🏷️ 성능#수정 후 빠르게 재생|수정 후 빠르게 재생]]
	- [[#⚙️ 설정#🏷️ 디버그|🏷️ 디버그]]
		- [[#🏷️ 디버그#애셋 직렬화 방식 통일|애셋 직렬화 방식 통일]]
		- [[#🏷️ 디버그#프로젝트 렌더링 파이프라인 확인|프로젝트 렌더링 파이프라인 확인]]
- [[#💾 개념|💾 개념]]
	- [[#💾 개념#🏷️ General|🏷️ General]]
		- [[#🏷️ General#.meta 파일|.meta 파일]]
		- [[#🏷️ General#Assembly Definition (asmdef)|Assembly Definition (asmdef)]]
	- [[#💾 개념#🏷️ Script|🏷️ Script]]
		- [[#🏷️ Script#재정의(override) 가능한 메서드|재정의(override) 가능한 메서드]]
		- [[#🏷️ Script#Unity : Coroutine|Unity : Coroutine]]
		- [[#🏷️ Script#Managed Object|Managed Object]]
- [[#📖 Manual|📖 Manual]]
	- [[#📖 Manual#🏷️ Component|🏷️ Component]]
		- [[#🏷️ Component#Rigidbody|Rigidbody]]
			- [[#Rigidbody#Body Type|Body Type]]
		- [[#🏷️ Component#CharacterController|CharacterController]]
		- [[#🏷️ Component#Mesh Renderer|Mesh Renderer]]
		- [[#🏷️ Component#Cinemachine|Cinemachine]]
			- [[#Cinemachine#Aim|Aim]]
		- [[#🏷️ Component#Line Renderer|Line Renderer]]
	- [[#📖 Manual#🏷️ Script|🏷️ Script]]
		- [[#🏷️ Script#Rect Transform|Rect Transform]]
		- [[#🏷️ Script#TMP_Text|TMP_Text]]
		- [[#🏷️ Script#OnRenderImage()|OnRenderImage()]]
		- [[#🏷️ Script#`[ImageEffectOpaque]`|`[ImageEffectOpaque]`]]
		- [[#🏷️ Script#Graphics.Blit()|Graphics.Blit()]]
		- [[#🏷️ Script#`OnAudioFilterRead(float[] data, int channels)`|`OnAudioFilterRead(float[] data, int channels)`]]
	- [[#📖 Manual#🏷️ UI|🏷️ UI]]
		- [[#🏷️ UI#Scroll View|Scroll View]]
	- [[#📖 Manual#🏷️ Shader Graph|🏷️ Shader Graph]]
		- [[#🏷️ Shader Graph#노드|노드]]
	- [[#📖 Manual#🏷️ Settings|🏷️ Settings]]
		- [[#🏷️ Settings#오클루전 컬링 활성화하는 법|오클루전 컬링 활성화하는 법]]
- [[#📄 Detail|📄 Detail]]
	- [[#📄 Detail#🏷️ Editor|🏷️ Editor]]
		- [[#🏷️ Editor#Import|Import]]
		- [[#🏷️ Editor#커서 어케 바꿈|커서 어케 바꿈]]
	- [[#📄 Detail#🏷️ Script|🏷️ Script]]
		- [[#🏷️ Script#GetKey 차이|GetKey 차이]]
		- [[#🏷️ Script#GetAxis, GetAxisRaw 차이|GetAxis, GetAxisRaw 차이]]
		- [[#🏷️ Script#private void vs void|private void vs void]]
		- [[#🏷️ Script#변수를 꼭 밖으로 뺄 이유는 없다|변수를 꼭 밖으로 뺄 이유는 없다]]
	- [[#📄 Detail#🏷️ Physics|🏷️ Physics]]
		- [[#🏷️ Physics#Collision|Collision]]
		- [[#🏷️ Physics#Trigger|Trigger]]
	- [[#📄 Detail#🏷️ Graphic|🏷️ Graphic]]
		- [[#🏷️ Graphic#Image vs Raw Image|Image vs Raw Image]]
		- [[#🏷️ Graphic#모델 노말 계산 설정|모델 노말 계산 설정]]
	- [[#📄 Detail#🏷️ Component|🏷️ Component]]
		- [[#🏷️ Component#Animation Rigging|Animation Rigging]]
	- [[#📄 Detail#🏷️ Animation|🏷️ Animation]]
- [[#🛠️ Editor Script|🛠️ Editor Script]]
	- [[#🛠️ Editor Script#🏷️ `MenuItem()`|🏷️ `MenuItem()`]]
		- [[#🏷️ `MenuItem()`#단축키 지정|단축키 지정]]
		- [[#🏷️ `MenuItem()`#우선순위 지정|우선순위 지정]]
- [[#🖼️ UI Toolkit|🖼️ UI Toolkit]]
	- [[#🖼️ UI Toolkit#🏷️ Tip|🏷️ Tip]]
	- [[#🖼️ UI Toolkit#🏷️ 문법|🏷️ 문법]]
		- [[#🏷️ 문법#태그|태그]]
		- [[#🏷️ 문법#콜백 함수|콜백 함수]]
		- [[#🏷️ 문법#네임스페이스|네임스페이스]]
		- [[#🏷️ 문법#붙어있는 Class 확인|붙어있는 Class 확인]]
		- [[#🏷️ 문법#메뉴 만들기|메뉴 만들기]]
		- [[#🏷️ 문법#좌표계 기준 바꾸기|좌표계 기준 바꾸기]]
		- [[#🏷️ 문법#요소 숨기기|요소 숨기기]]
		- [[#🏷️ 문법#`targetObject`를 사용하는 이유|`targetObject`를 사용하는 이유]]
	- [[#🖼️ UI Toolkit#🦫 Troubleshooting|🦫 Troubleshooting]]
		- [[#🦫 Troubleshooting#border가 안 보임|border가 안 보임]]
		- [[#🦫 Troubleshooting#TextField 문제|TextField 문제]]
		- [[#🦫 Troubleshooting#Object Field가 uxml 컴파일이 안됨|Object Field가 uxml 컴파일이 안됨]]
		- [[#🦫 Troubleshooting#부모 요소 style과 관련 있어서 바로 렌더링 안됨|부모 요소 style과 관련 있어서 바로 렌더링 안됨]]
- [[#💻 CSharp|💻 CSharp]]
	- [[#💻 CSharp#🏷️ 구문|🏷️ 구문]]
		- [[#🏷️ 구문#`using` (네임스페이스 x)|`using` (네임스페이스 x)]]
		- [[#🏷️ 구문#custom 프로퍼티 backing field|custom 프로퍼티 backing field]]
	- [[#💻 CSharp#🏷️ Type 관련|🏷️ Type 관련]]
		- [[#🏷️ Type 관련#`IsAssignableFrom(A)`|`IsAssignableFrom(A)`]]
		- [[#🏷️ Type 관련#BindingFlags|BindingFlags]]
	- [[#💻 CSharp#🏷️ 접근 제한자|🏷️ 접근 제한자]]
		- [[#🏷️ 접근 제한자#internal|internal]]
	- [[#💻 CSharp#🏷️ 특성(Attribute)|🏷️ 특성(Attribute)]]
		- [[#🏷️ 특성(Attribute)#`[StructLayout()]`|`[StructLayout()]`]]
- [[#📦 애셋 사용법|📦 애셋 사용법]]
	- [[#📦 애셋 사용법#Analytic Volumetric Light|Analytic Volumetric Light]]
	- [[#📦 애셋 사용법#VRoid|VRoid]]
- [[#🦫 디버깅|🦫 디버깅]]
	- [[#🦫 디버깅#🏷️ Editor|🏷️ Editor]]
		- [[#🏷️ Editor#Tile Pallete 타일 크기 작음|Tile Pallete 타일 크기 작음]]
		- [[#🏷️ Editor#라이트에 쿠키 넣고 텍스쳐 타입 바꿨더니 조명 꺼짐|라이트에 쿠키 넣고 텍스쳐 타입 바꿨더니 조명 꺼짐]]
		- [[#🏷️ Editor#Render Texture 크기 변경 안됨|Render Texture 크기 변경 안됨]]
		- [[#🏷️ Editor#Package Export 종속성만 체크가 안됨|Package Export 종속성만 체크가 안됨]]
		- [[#🏷️ Editor#PSD import가 안됨|PSD import가 안됨]]
		- [[#🏷️ Editor#SRP Batcher가 없음|SRP Batcher가 없음]]
	- [[#🦫 디버깅#🏷️ 인게임|🏷️ 인게임]]
		- [[#🏷️ 인게임#📌 Collision 관련|📌 Collision 관련]]
		- [[#🏷️ 인게임#오브젝트들 전부 살짝 흐림|오브젝트들 전부 살짝 흐림]]
		- [[#🏷️ 인게임#Cinemachine 따라가기 덜덜 떨림|Cinemachine 따라가기 덜덜 떨림]]
		- [[#🏷️ 인게임#콜라이더 적용해도 벽뚫|콜라이더 적용해도 벽뚫]]
		- [[#🏷️ 인게임#플레이어가 벽에 달라붙음|플레이어가 벽에 달라붙음]]
		- [[#🏷️ 인게임#플레이어가 벽에 닿으면 계속 점프 가능함|플레이어가 벽에 닿으면 계속 점프 가능함]]
		- [[#🏷️ 인게임#Navmesh Bake 안 보임|Navmesh Bake 안 보임]]
		- [[#🏷️ 인게임#Raycast 안됨|Raycast 안됨]]
		- [[#🏷️ 인게임#머테리얼을 Transparent로 설정해도 살짝 불투명|머테리얼을 Transparent로 설정해도 살짝 불투명]]
		- [[#🏷️ 인게임#플레이어 이동에 약간 딜레이|플레이어 이동에 약간 딜레이]]
		- [[#🏷️ 인게임#스프라이트 마스크 어떻게 씀?|스프라이트 마스크 어떻게 씀?]]
		- [[#🏷️ 인게임#Camera.main이 null임|Camera.main이 null임]]
		- [[#🏷️ 인게임#DontDestroyOnLoad() 해도 사라짐|DontDestroyOnLoad() 해도 사라짐]]
		- [[#🏷️ 인게임#콜라이더가 분명 하나인데 더 달려있음|콜라이더가 분명 하나인데 더 달려있음]]
		- [[#🏷️ 인게임#Rigidbody 중력 작용 안 함|Rigidbody 중력 작용 안 함]]
		- [[#🏷️ 인게임#sorting layer 바꿨더니 검은색 됨|sorting layer 바꿨더니 검은색 됨]]
		- [[#🏷️ 인게임#위치 순간이동 로직 짰는데 순간이동 안 함|위치 순간이동 로직 짰는데 순간이동 안 함]]
		- [[#🏷️ 인게임#fbx export 했는데 blender에서 인식 안돼|fbx export 했는데 blender에서 인식 안돼]]
		- [[#🏷️ 인게임#font asset 한글 폰트인데 글자가 깨져|font asset 한글 폰트인데 글자가 깨져]]
	- [[#🦫 디버깅#🏷️ 스크립트|🏷️ 스크립트]]
		- [[#🏷️ 스크립트#using Cinemachine이 안 먹힘|using Cinemachine이 안 먹힘]]
		- [[#🏷️ 스크립트#Trigger가 안됨|Trigger가 안됨]]
		- [[#🏷️ 스크립트#print()가 안됨|print()가 안됨]]
		- [[#🏷️ 스크립트#JsonUtility 불러오기가 안됨|JsonUtility 불러오기가 안됨]]
		- [[#🏷️ 스크립트#동적 타입 둘을 비교하고 싶음|동적 타입 둘을 비교하고 싶음]]
	- [[#🦫 디버깅#🏷️ Shader Graph|🏷️ Shader Graph]]
		- [[#🏷️ Shader Graph#2D Sprite Texture 연결했는데 전부 단색으로 나옴|2D Sprite Texture 연결했는데 전부 단색으로 나옴]]
	- [[#🦫 디버깅#🏷️ UI|🏷️ UI]]
		- [[#🏷️ UI#9-slice 적용 안됨|9-slice 적용 안됨]]
	- [[#🦫 디버깅#🏷️ 협업|🏷️ 협업]]
		- [[#🏷️ 협업#깃 pull 할 때마다 메타파일 갱신|깃 pull 할 때마다 메타파일 갱신]]
- [[#🚀 최적화|🚀 최적화]]
	- [[#🚀 최적화#유나이트 서울 2020 - 최대 성능을 위한 최적화 팁|유나이트 서울 2020 - 최대 성능을 위한 최적화 팁]]
		- [[#유나이트 서울 2020 - 최대 성능을 위한 최적화 팁#플랫폼별 적절한 Tris(폴리곤) 개수 가이드라인|플랫폼별 적절한 Tris(폴리곤) 개수 가이드라인]]
		- [[#유나이트 서울 2020 - 최대 성능을 위한 최적화 팁#씬 내 폴리곤 최적화|씬 내 폴리곤 최적화]]



## 📌 팁
---

- 씬 뷰 좌측 상단 Global을 Local로 바꾸면 해당 오브젝트이 rotation한 대로 축이 변경됨
- 추노마크 없애기 : Project Settings > Player > Splash Image > Show Splash Screen
- [debug 쉽게 하기](https://github.com/JohnBaracuda/com.baracuda.runtime-monitoring?tab=readme-ov-file) 
  - Asset Store에서 등록해놨으니 PackageManager에서 설치
  - Tools에서 세팅하기 
  - `using Baracuda.Monitoring;` 
  - 인스턴스는 시작할 때 `this.StartMonitoring()`
- Unity 엔진 내부에서는 **값이 실제로 바뀔 때**만 C++ 레이어로 내려가서 `Renderer::SetEnabled()`  등 프로퍼티를 호출
- 프로젝트 이름 바꾸기 : UnityProject에 있는 프로젝트 폴더 이름 바꾸고 sln 삭제한 후 열기, Build Settings > Player Settings > Product name도 바꾸기

### 단축키

- 창 전체화면 : Shift + Space
- 카메라, 조명 등을 씬 뷰 시선에 맞추기 : 선택하고 Ctrl+Sfhit+F

### 에디터
- 프리팹 옆에 있는 화살표 누르면 프리팹 편집기로 바로 들어갈 수 있다.

## ✂️ 스니펫
---

### 2D 랜덤 방향

```cs
Random.insideUnitCircle.normalized
```

### 싱글톤

```cs
using UnityEngine;

public class Singleton<T> : MonoBehaviour where T : MonoBehaviour
{
    public static T Instance { get; private set; }

    protected virtual void Awake()
    {
        if (Instance == null)
        {
            Instance = this as T;
        }
        else if (Instance != this)
        {
            Destroy(gameObject);
        }
    }
}
```

### Player Input

```cs
public class PlayerMove : MonoBehaviour
{
    [SerializeField] float moveSpeed;
    [SerializeField] InputActionReference inputAction;
    CharacterController cc;

    void Start()
    {
        cc = GetComponent<CharacterController>();
    }

    void Update()
    {
        Vector2 moveInput = inputAction.action.ReadValue<Vector2>();
        Vector3 moveDirection = new Vector3(moveInput.x, 0, moveInput.y).normalized;
        cc.Move(moveDirection * moveSpeed * Time.deltaTime);
    }
}
```


## ⚙️ 설정
---

### 🏷️ 성능

#### 수정 후 빠르게 재생
Edit → Project Settings → Editor → Enter Play Mode Options


### 🏷️ 디버그

#### 애셋 직렬화 방식 통일
Edit - Project Settings - Editor - Asset Serialization - Force Text로 바꾸기

#### 프로젝트 렌더링 파이프라인 확인
Edit - Project Settings - Graphics - Scriptable Pipeline Settings 확인



## 💾 개념
---

### 🏷️ General
#### .meta 파일
컴포넌트 간의 연결과 같은 메타 정보들을 담고 있다.
유니티 에디터에서 파일 위치나 이름 바꾼거 아니면 이거 때문에 정보 소실.

깃허브에 커밋할 때 .meta 빠뜨리면 안되고
외부에 깃 말고 보낼 땐 .unitypackage로 만들어라.

#### Assembly Definition (asmdef)
- 기본적으로 Unity 프로젝트의 모든 C# 스크립트는 UnityEngine.dll에 하나로 컴파일한다.
- 이때 `.asmdef` 파일을 추가하면 해당 폴더와 하위 폴더의 스크립트들을 별도의 어셈블리로 컴파일하게 만들 수 있다.
- 근데 의존성을 일일이 추가해줘야 한다. 불편하긴 하지만 의존성 관리에 용이.

### 🏷️ Script
#### 재정의(override) 가능한 메서드
- 부모 클래스의 메서드가 `virtual`, `abstract`, 또는 `override`로 선언되지 않았다면, 자식 클래스에서 해당 메서드를 `override`로 재정의할 수 없습니다.
- Unity의 `Awake`는 기본적으로 MonoBehaviour의 메서드로 `virtual`이 아니므로, 재정의하려면 부모 클래스에서 `Awake`를 `virtual`로 명시해야 합니다.

#### Unity : Coroutine

**개념 및 원리**
- 설정한 만큼 멈췄다가 다시 실행
- 멈췄던 위치에서 다시 실행됨
- 긴 비동기 작업할 때 쓰면 됨
- 멀티쓰레딩은 아니다

**문제 및 해결**
- 디버깅 어렵다. 로그 넣어주자.
- 다 쓰고 안 꺼주면 성능 문제.
- 무거운 연산 쓰면 프레임 드랍. 프레임마다 쪼개서 실행하기.

**끄는 법**
- StopCoroutine(), StopAllCoroutines()
- 코루틴 붙은 오브젝트 SetActive(false), Destroy()
- Monobehaviour 스크립트는 enabled false로 해도 코루틴 안 꺼짐

#### Managed Object
- .NET 런타임(예: CLR, Common Language Runtime)의 관리 아래 존재하는 객체
- 메모리 할당, 해제, 가비지 컬렉션 같은 작업을 자동 관리
- 예
  - new로 만든 C# 객체들 (예: new MyClass())
  - Unity의 MonoBehaviour, ScriptableObject 같은 컴포넌트 객체들
  - 배열, 리스트, 딕셔너리 등 .NET 기본 자료구조들
- 이거 쓰면 Burst Compiler 못 씀


## 📖 Manual
---

### 🏷️ Component

#### Rigidbody
##### Body Type
- Dynamic : 완전히 물리 연산
- Kinematic : 물리 연산 없이 충돌 감지만 가능. 움직이려면 rb.MovePosition()
- Static : 절대 안 움직임
#### CharacterController
- 정확한 충돌 감지 (벽 통과 방지)  
- 중력, 계단 이동, 경사면 처리 가능  
- Rigidbody 없이도 이동 및 점프 구현 가능  
- 플레이어 이동을 세밀하게 조정 가능  
- 물리 연산이 불필요하여 성능 최적화 가능 

#### Mesh Renderer
- 기본 역할: 정적(Static) 또는 변형되지 않는 3D 메시에 대한 렌더링을 처리.
- 사용 예시: 건물, 바위, 가구 등 변형되지 않는 오브젝트.
- 특징:
  - Transform 컴포넌트로 위치, 회전, 크기만 변경 가능.
  - 메시의 정점(Vertex)이나 형태가 바뀌지 않음.
  - 단순한 렌더링 파이프라인을 사용하며, 계산량이 적음.
  - 머티리얼 및 셰이더와 호환성이 높음.
#### Cinemachine
##### Aim
1. Do nothing  : 카메라가 대상을 바라보지 않고, 별도의 조정 없이 고정된 상태로 유지됩니다.
2. Composer : 자동으로 목표 오브젝트를 따라가며 화면에서 적절한 위치에 유지되도록 합니다. 카메라가 부드럽게 따라가는 효과가 있습니다.
3. Group Composer : 여러 개의 대상을 포함하는 그룹을 추적하는 기능입니다. 그룹 내 대상의 위치를 조정하여 카메라가 자연스럽게 움직이도록 합니다.
4. Hard Look At : 카메라가 항상 목표 오브젝트를 정확하게 바라보도록 강제하는 방식입니다. 회전이 즉각적으로 적용되며 자연스러운 움직임 없이 즉시 방향을 맞춥니다.
5. POV : 1인칭 혹은 3인칭 조작 방식에서 사용되며, 플레이어 입력(마우스 또는 컨트롤러)을 기반으로 카메라가 회전합니다. FPS(1인칭 슈팅 게임) 또는 TPS(3인칭 액션 게임) 카메라에서 많이 사용됩니다.
6. Same As Follow Target : 카메라가 설정된 대상의 회전을 그대로 따라갑니다.

#### Line Renderer
Scene Tools : 점 세개 누르면 점 옮기기
Positions : 정점 추가
중앙 빨간 선 : 폭 조절
Conrner Vertices : 모서리 둥글기
End Cap Vertices : 끝점 둥글기

### 🏷️ Script

#### Rect Transform
- RectTransform.rect는 Scale With Screen Size일 때 Reference Resolution을 반환
- Camera.WorldToScreenPoint()는 특정 월드 좌표의 스크린 좌표계를 반환
- Camera.WorldToViewportPoint()는 특정 월드 좌표의 뷰포트 좌표계를 반환
- rect transform의 anchor가 범위라면 부모 오브젝트(캔버스도 포함)를 상대적 비율로 덮음
- anchor의 y를 각각 0과 1로 두면 width만 조절하면 알아서 화면 꽉 채워줌
- UI 요소 크기 공식 : actualSize = (anchorMax - anchorMin) * 부모크기 + sizeDelta

#### TMP_Text
| 항목         | TMP_Text      | TextMeshProUGUI              | TextMeshPro             |
| ---------- | ------------- | ---------------------------- | ----------------------- |
| 타입         | 부모 (공통 인터페이스) | 자식 (UI용)                     | 자식 (3D용)                |
| 렌더링 기반     | N/A           | Canvas (UGUI, RectTransform) | MeshRenderer, Transform |
| 사용 위치      | N/A           | UI 패널, 버튼, 인벤토리 등            | 3D 공간, 월드 오브젝트          |
| 코드에서 공통 속성 | `.text` 등 동일  | `.text` 등 동일                 | `.text` 등 동일            |

#### OnRenderImage()
- 카메라 포스트 프로세싱에 사용되는 함수
- Unity 카메라가 씬을 렌더링한 직후에 호출됨
- 렌더링된 결과(`source`)를 받아서 필터/이펙트 처리 후 `destination`에 출력하는 구조
- 이 함수가 호출되려면, 스크립트가 카메라에 붙어 있어야 하고, 
  해당 카메라에 depthTextureMode 또는 PostProcess 관련 설정이 있어야 함.

#### `[ImageEffectOpaque]`
- 렌더 순서를 opaque 렌더링 이후(transparent 이전)로 설정

#### Graphics.Blit()
- Blit = Bit Block Transfer : 텍스처를 복사하거나 가공해서 다른 텍스쳐로 넘기는 함수
- `Graphics.Blit(source, destination);` : source 이미지를 destination으로 그냥 복사
- `Graphics.Blit(source, destination, _Material);` : `_Material`에 연결된 셰이더를 사용해서 source를 처리한 뒤 destination에 씀

#### `OnAudioFilterRead(float[] data, int channels)`
- 오디오 처리할 때 콜백 함수. 
- data에 샘플들 담겨있다. (샘플 : 소리 크기 숫자, 이것들을 다 이으면 오디오 된다.)
- 채널 2개면 data에 번갈아가며 저장돼있다.
- 메인 쓰레드와 별개의 쓰레드에서 호출된다.

#### `ExposedRefernce<T>` 사용법

- ExposedReference는 Scriptable에 직렬화하여 저장한다
- 씬에 IExposedPropertyTable를 구현한 매니저를 만든다
- ExposedReference를 씬 내 오브젝트와 연결하거나 불러오려고 할 때 Resolve()와 같은 ExposedReference 내장 메서드에 매니저를 넣어서 호출한다
- 씬 내 오브젝트를 저장하려고 할 때 매니저에서 SetReferenceValue()를 호출하는 것을 잊으면 안된다
- ExposedReference는 구조체라서, 메서드에 파라미터로 넘겨도 원본이 바뀌지 않는다는 것 주의

### 🏷️ UI

#### Scroll View
- Content에 element들을 전부 넣는다
- Content에 Vertical Layout Group 추가 > Child Alignment 조정
- Content에 Content Size Fitter 추가 > Vertical Fit Preferred Size
- 그래도 안되면 Viewport > Scroll Rect> Content > Content 할당

### 🏷️ Shader Graph

#### 노드
- Scanline 효과: Checkerboard

### 🏷️ Settings

#### 오클루전 컬링 활성화하는 법
- Occluder Static이나 Occludee Static 체크하고
- Window > Rendering > Occlusion Culling > Bake
- Scene View의 Visualisation 탭 활성화하여 미리 보기


## 📄 Detail
---
### 🏷️ Editor

- 오브젝트들 묶었을 때 피벗은 부모 오브젝트의 위치

#### Import
- 블랜더 export할 때 : Selected Objects, Apply Transform (유니티 원치않는 회전 막기)
- 유니티로 import할 때
	- Model > import 붙은 옵션 끄기
	- Model > Scale Factor 조절하여 크기 조절
	- Material Creation Mode > None
	- Animation > Import Animation 끄기

- 모델의 크기는 성능에 영향 안 주고, 버텍스와 폴리곤 개수가 성능에 영향 미친다

#### 커서 어케 바꿈
Project Settings - Player - Default Cursor

### 🏷️ Script

#### GetKey 차이
GetKey : 해당 키 누르는 동안 true 반복적 반환  
GetKeyDown : 해당 키 누르면 단 한 번 true 반환  
GetKeyUp : 해당 키 누름 해제되면 true 한 번 반환

#### GetAxis, GetAxisRaw 차이
Input.GetAxis() : 사용자가 키를 누르면 값이 0에서 1로 서서히 증가하며, 키를 떼면 1에서 0으로 서서히 감소합니다.
Input.GetAxisRaw() : 키를 누르는 순간 1이 되고, 키를 떼면 즉시 0으로 돌아갑니다.
#### private void vs void
접근 제한자는 생략해도 되지만 가독성을 위해 명시적으로 추가하는게 좋다.

#### 변수를 꼭 밖으로 뺄 이유는 없다
```cs
void Update()
{
	GameObject player = GameObject.FindWithTag("Player");
}
```

player를 update 문 바깥에서 전역 변수로 선언한다고 해서 메모리가 아껴지진 않는다. 
어차피 update 문이 끝나면 스택 메모리가 자동으로 정리되기 때문이다.

### 🏷️ Physics

#### Collision
- OnCollisionEnter는 Rigidbody가 있는 최상위 부모 오브젝트 기준으로 collision 가져옴
- OnCollisionEnter에선 linearVelocity 0되므로 relativeVelocity 써야 함
- 둘 중 하나라도 트리거 체크돼있으면 CollisionEnter 작동 안 함
- `collision.collider`은 상대방 콜라이더를 의미한다

#### Trigger
- OnTriggerEnter는 정확히 닿은 오브젝트 기준으로 collider 가져옴
- rigidbody continous 설정해도 고속 물체 감지 불가
- TriggerEnter(Collider col)에서 굳이 col.gameObject.CompareTag()할 필요 없이 col.CompareTag()


### 🏷️ Graphic

#### Image vs Raw Image
- Image는 UI 디자인 요소에 적합하며, 간단하고 효율적으로 사용 가능합니다.
- Raw Image는 동적 콘텐츠나 렌더 텍스처를 처리하거나, 셰이더 효과를 적용할 때 적합합니다.

#### 모델 노말 계산 설정
model import settings에서 Normals를 Calculate로 바꾸고
Smoothing Angle을 조절하면 폴리곤 단위에 가깝게 노말 계산


### 🏷️ Component

#### Animation Rigging

- 런타임에 굳이 Target 바꾸지 말고 Target의 Transform을 바꿔라.

### 🏷️ Animation

- 모델을 클릭해야 Animation Clip을 수정할 수 있다
- Animator Controller에서 새 레이어로 BlendShape override 가능하다
- Animator Clip에서 스크롤바 늘려놔서 한꺼번에 보이게 하기


## 🛠️ Editor Script
---

UnityEditor namespace를 추가하고 EditorWindow를 상속받은 후 `[MenuItem("Window/메뉴 이름")]` 이 특성을 static 메서드 앞에 붙이면 지정한 메뉴 클릭 시 해당 메서드 호출


### 🏷️ `MenuItem()`

#### 단축키 지정

| 단축키 기호 | 의미                         |
| ------ | -------------------------- |
| `%`    | Ctrl (Windows) / Cmd (Mac) |
| `#`    | Shift                      |
| `&`    | Alt                        |
| 알파벳    | 단일 문자 키                    |

```cs
[MenuItem("Tools/My Tool %#&g")]
```

→ Ctrl + Shift + Alt + G

#### 우선순위 지정

```cs
[MenuItem("Tools/First", false, 10)]
public static void First() { }

[MenuItem("Tools/Second", false, 20)]
public static void Second() { }
```

구분선은 **우선순위 값이 11의 배수에서 다음 항목과 차이가 11 이상일 때** 자동으로 생긴다.


## 🖼️ UI Toolkit
---

### 🏷️ Tip

- visualelement에 추가한 후에 이벤트 등록해도 된다
- 동적인 요소는 uss에서 name으로 스타일 지정하는게 불가능하다.

uxml은 쓰레기라 z-index를 지원하지 않음
- 요소가 먼저 추가될수록 아래
- 나중에 추가될수록 위
- 부모가 먼저 그려지고, 그 위에 자식들이 순서대로 그려진다

style.width → 설정용 (float 아님)  → float로 쓰려면 .value.value 붙여야 함
resolvedStyle.width → 계산 결과용 (float) → 한 프레임 뒤에 확정

flex-grow 지정했는데 다른 요소 무시하고 전체 길이 차지해버림
- 부모 요소에 display: flex, flex-direction: row; 지정
- 무시당한 요소에서 position: absolute; 삭제

`EventCallback<MouseMoveEvent>` 이런 식으로 delegate 선언해놓으면 Register할 때 무슨 콜백인지 명시 안 하고 바로 구독된다.

UI Builder > uxml 선택 > Inspector > Editor Extension Authoring 체크하면 Editor에서만 쓸 수 있는 다양한 Component 추가됨

부모 크기가 0일때 자식을 보이게 하려면 `Position.Absolute;` 설정

dropdown.choices에 List를 넣고 List에 "분류/항목" 식으로 요소를 넣어주면 알아서 항목들을 분류해준다.

### 🏷️ 문법

width px, % 설정 : 기본은 px. % 단위로 설정하려면 `style.width = new Length(100, LengthUnit.Percent)`


#### 태그

| UXML 태그           | C# 타입         | 설명                   |
| ----------------- | ------------- | -------------------- |
| `<VisualElement>` | VisualElement | 모든 UI의 기본 컨테이너, 빈 블록 |
| `<Label>`         | Label         | 단순 텍스트 표시            |
| `<Button>`        | Button        | 버튼, 클릭 이벤트 처리 가능     |
| `<TextField>`     | TextField     | 텍스트 입력 필드            |
| `<Toggle>`        | Toggle        | 체크박스 또는 토글 스위치       |
| `<ScrollView>`    | ScrollView    | 스크롤 가능한 영역           |
| `<ListView>`      | ListView      | 리스트형 데이터 UI          |
| `<Image>`         | Image         | 이미지 표시               |

#### 콜백 함수

`RegisterCallback<GeometryChangedEvent>(OnGeometryChanged);`
: UI 요소의 크기나 위치가 변경될 때 OnGeometryChanged 콜백을 호출

`generateVisualContent += OnGenerate;` 
: custom geometry VisualElement를 그릴 때 사용한다. 
맨 처음 그려질 때나 repaint가 필요할 때 호출됨.
매 프레임마다 호출되진 않음.
`MarkDirtyRepaint()` 호출하면 `OnGenerate()`도 호출됨.


#### 네임스페이스

```cs
<ui:UXML xmlns:ui="UnityEngine.UIElements">
    <ui:Label text="Hello" />
</ui:UXML>
```

#### 붙어있는 Class 확인
```cs
Debug.Log(string.Join(", ", node.GetClasses()));
```

#### 메뉴 만들기
- `ContextualMenuManipulator`
- `contextualMenuPopulateEvent`
- MouseDown + `GenericMenu`

#### 좌표계 기준 바꾸기
`Layer1Element.ChangeCoordinatesTo(Layer2Element, localPosInL1);`

#### 요소 숨기기
`DisplayStyle.None`과 `Visibility.Hidden`의 차이 : `DisplayStyle.None`는 그 요소가 차지하던 공간까지 제거됨
 `Visibility.Hidden`과 `visible = false;`의 차이 : `visible = false;`는 공간도 안 차지하고 이벤트도 안 받음 (기존 스타일과 충돌하면 안 사라질수도)

#### `targetObject`를 사용하는 이유
SerializedObject는 Unity의 인스펙터에서 값을 직렬화하고 편집하기 위해 사용하는 래퍼 클래스다.
하지만 이것은 진짜 객체 자체가 아니다. 직렬화된 필드 정보를 통해 간접적으로 데이터를 다루는 것이다.
SerializedObject를 통해 실제 원본 객체에 접근하려면 .targetObject를 써야 한다.


### 🦫 Troubleshooting

#### border가 안 보임
border의 alpha는 기본 0이라서 두께 지정해도 바로 안 보임.

#### TextField 문제
- 여러 줄 입력을 위해 multiline을 true로 바꾸면 height 설정이 무효화됨 : `nodeTextField.verticalScrollerVisibility = ScrollerVisibility.AlwaysVisible;`
- 엔터를 누르면 한 줄 밀려 올라가며 기존 텍스트가 보이지 않게 됨 : `input.style.unityTextAlign = TextAnchor.UpperLeft;`

#### Object Field가 uxml 컴파일이 안됨
```xml
<UXML xmlns="UnityEngine.UIElements" xmlns:uie="UnityEditor.UIElements">
<uie:ObjectField name="myField" />
```

uxml 태그에 xmlns으로 namespace 지정해놨다면 ui builder가 붙여놓은 namespace와 중복되어 이상한 경로를 가리킴. 별도로 namespace 지정하는 attribute 추가해야함.

#### 부모 요소 style과 관련 있어서 바로 렌더링 안됨
`RegisterCallbackOnce<GeometryChangedEvent>(_ => LayoutBody());`




## 💻 CSharp
---

### 🏷️ 구문

#### `using` (네임스페이스 x)

```cs
using (var resource = new SomeResource())
{
    // 이 블록 안에서 resource 사용
}
// 블록 끝나면 resource.Dispose() 자동 호출됨
```

`IDisposable` 인터페이스를 구현한 객체의 `Dispose()` 메서드를 자동으로 호출해주는 구문.
GC가 못 닫는 파일 핸들, 네트워크 소켓, 네이티브 메모리 같은 거 자동으로 `Dispose()`해준다.

#### custom 프로퍼티 backing field

```cs
private bool _highlight;
public bool Highlight
{
    get => _highlight;
    set
    {
        if (_highlight == value) return;
        _highlight = value;
        MarkDirtyRepaint();
    }
}
```

부수 효과가 있는 custom getter/setter는 backing field를 두어야 한다.


### 🏷️ Type 관련

#### `IsAssignableFrom(A)` 
: A가 해당 타입을 상속하거나 구현하고 있는지 판단

#### BindingFlags

```cs
var fields = type.GetFields(
    BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly
);
```
- BindingFlags.Instance: 인스턴스 필드 (static 제외)
- BindingFlags.Public: public 필드 포함
- BindingFlags.NonPublic: private, protected 필드 포함
- BindingFlags.DeclaredOnly: 해당 클래스에 직접 선언된 필드만 포함, 부모 클래스에서 상속된 필드는 제외

### 🏷️ 접근 제한자
#### internal
private 같은 접근 제한자의 일종.
해당 코드(클래스, 메서드, 필드 등)가 같은 어셈블리 안에서만 접근 가능하도록 만듦.
Burst 컴파일하면 using으로 자동 Dispose 호출 안 해준다.


### 🏷️ 특성(Attribute)
#### `[StructLayout()]`
- .NET 런타임에서 구조체나 클래스의 메모리 배치를 지정할 때 사용
- `StructLayout(LayoutKind.Sequential)` : 필드를 선언한 순서대로 메모리에 배치하라




## 📦 애셋 사용법
---
### Analytic Volumetric Light

초기 설정 제대로 다 했는데도 제대로 안 보임 : Global Volume에 추가한 override에서 Air Density 다 켜지 말 것

Base Light를 설정한 후에 원본 빛을 바꿨다면 Copy From Light Component


### VRoid

vrm importer : https://github.com/vrm-c/UniVRM
- v0.129.0은 오류 발생, v0.128.3 사용.

눈 깜빡임 : [https://gist.github.com/AISebas/cc799c262ff71cd7d1e92f0dd7e5e5fb](https://gist.github.com/AISebas/cc799c262ff71cd7d1e92f0dd7e5e5fb)  
눈 따라가기 : VRMInstance > select UI > LookAt

**믹사모 애니메이션 적용 방법**
- unity package manager > Unity Registry > fbx exporter 설치
- 모델을 씬에 올린 뒤 export fbx (안되면 fbx exporter 재설치)
- 믹사모에 fbx 파일 올린 뒤에 애니메이션 다운 받기
- 믹사모 파일 가져온 뒤 Rig > Animation Type > Humanoid
- 가져온 파일에서 애니메이션 클립만 따로 복사
- 애니메이션 클립 루트 모션 관련 필요한대로 설정

**표정 제어**
Fcl_All 계열은 VRM10Instance에서 덮어씌워버린다.
그 이외 파라미터들은 애니메이터로 제어 가능하다.

1. UniVRM의 기능을 이용하지 않을 거라면
Update Type을 None으로 두고 Animator로만 제어한다.

2. UniVRM 무시하고 계속 덮어씌우기
애니메이션 클립에서 키프레임을 하나 더 생성해서 애니메이션이 계속 재생되게 만들면 UniVRM의 덮어씌우기가 무시된다.

3. UniVRM의 Expression API 사용하기
- import했던 VRM 모델로 간다
- VRM 탭 > Extract Meta And Expressions
```cs
using UnityEngine;
using UniVRM10;

public class ChangeExpression : MonoBehaviour
{
    Vrm10Instance vrm;
    public ExpressionKey smile;

    void Start()
    {
        vrm = GetComponent<Vrm10Instance>();
        smile = ExpressionKey.CreateFromPreset(ExpressionPreset.happy);
    }

    void Update()
    {
        vrm.Runtime.Expression.SetWeight(smile, 1);
    }
}
```



**워크플로 비교**

| 항목                   | VRM → FBX 변환 후 사용                             | UniVRM 그대로 사용                                                                 |
| -------------------- | --------------------------------------------- | ----------------------------------------------------------------------------- |
| 리깅/애니메이션         | Unity Humanoid 리깅 자동 감지 → Animator 사용. 문제 없음. | 동일. 다만 VRM 표정(BlendShape)·눈동자 시선 제어가 이미 세팅됨.                                  |
| 표정 · BlendShape  | 변환 시 클립 이름·순서가 흐트러질 수 있어 수동 재매핑 필요.           | `VRMBlendShapeProxy`가 웃음/슬픔/놀람 등 표준 슬롯을 유지. 바로 Playable API·Timeline에서 호출 가능. |
| 헤어/치마 물리         | Dynamic Bone·Unity Physics 등을 직접 붙여야 함.       | `VRMSpringBone`이 메타데이터 기반으로 즉시 동작.                                            |
| 메타데이터 (작가, 라이선스) | FBX에는 안 남음 → 별도 관리 필요.                        | `VRMMeta` 컴포넌트에 포함(저작자·라이선스·연령등급).                                            |
| 런타임 아바타 교체       | Addressables 혹은 애셋번들 직접 제작 필요.                | `VRMImporterContext.LoadAsync(byte[])` 하나로 외부 VRM 파일 로드 가능.                   |
| 빌드 크기·성능         | 컴포넌트 수가 적어 약간 가벼움.                            | 스크립트·컴포넌트 추가(≈ 20 ~ 50 KB, 무시 가능).                                            |
| 유지보수             | 표준 FBX 파이프라인 → 아티스트·툴 전환 쉬움.                  | UniVRM 업데이트(0.x → 1.x) 따라가야 함.                                                |
| VR/소셜 지원         | 직접 구현.                                        | VCI / VRM 1.0 규격과 호환.                                                         |

**UniVRM가 해주는 일**

| 컴포넌트                                          | 역할                                                   |
| --------------------------------------------- | ---------------------------------------------------- |
| `VRMHumanoidDescription`                      | IK 입력(목·눈·손) → Humanoid Rig 매핑 자동화                   |
| `VRMBlendShapeProxy`                          | 52 종 표준 BlendShape 슬롯 + 커스텀 클립 제어 API 제공             |
| `VRMSpringBone`, `VRMSpringBoneColliderGroup` | 머리카락·치마 물리(간단 반‑객체 동역학)                              |
| `VRMLookAtHead`, `VRMLookAtBoneApplyer`       | 카메라·타깃을 향해 눈/목 회전                                    |
| `VRMFirstPerson`                              | VR / 1인칭 렌더링 시 머리 숨김, 눈 깊이 클립 오프셋                    |
| `VRMMeta`                                     | Title, Author, Contact, License(商用/改変/再配布) 등 json 추출 |

| VRM 0.x                | VRM 1.0                                |
| ---------------------- | -------------------------------------- |
| **VRMBlendShapeProxy** | **`Vrm10Instance.Runtime.Expression`** |
| VRMLookAt              | `Vrm10Instance.Runtime.LookAt`         |
| VRMSpringBone          | `Vrm10Instance.Runtime.SpringBone`     |




## 🦫 디버깅
---

### 🏷️ Editor

#### Tile Pallete 타일 크기 작음
Tile Pallete 만들 때 Cell Size 1x1로 설정

#### 라이트에 쿠키 넣고 텍스쳐 타입 바꿨더니 조명 꺼짐
넣었던 쿠키 삭제했다가 다시 넣으면 켜질거임

#### Render Texture 크기 변경 안됨
Enable Compatible Format 체크 해제하고 바꿔보셈

#### Package Export 종속성만 체크가 안됨
Include all 체크 해제

#### PSD import가 안됨
Texture의 Inspector 상단에서 Importer를 PSD Importer로 바꾸셈

#### SRP Batcher가 없음
URP Asset > Rendering > 우측 상단 점 세개


### 🏷️ 인게임

#### 📌 Collision 관련

- OnTriggerEnter()는 Rigidbody를 Continous로 설정해도 고속 물체 감지 불가
- 둘 중 하나라도 Is Trigger 체크돼있으면 OnCollisionEnter() 작동 안 함
- OnCollisionEnter()에선 linearVelocity 대신 relativeVelocity 써야 함. 
  linearVelocity는 충돌 때문에 0됨. 
  relativeVelocity 쓸 땐 rb가 아니라 collision에서 가져와야 함.



#### 오브젝트들 전부 살짝 흐림
해상도를 Full HD로 바꾸고 1.5x로 돼있는 Scale을 1x로 바꾸기

#### Cinemachine 따라가기 덜덜 떨림
- Rigidbody > Interpolation > Interpolate로 변경
- Cinemachine Brain > Blend Update Method > Fixed Update

#### 콜라이더 적용해도 벽뚫
Rigidbody > Collision Detection > Continous로 변경

#### 플레이어가 벽에 달라붙음
Physics Material 2D > Friction 0 > 적용

#### 플레이어가 벽에 닿으면 계속 점프 가능함
캡슐 콜라이더 아래에 점프 가능여부 확인하는 작은 네모 콜라이더 만들면 됨

#### Navmesh Bake 안 보임
- Bake 하는 방법을 못 찾겠음 : Navmesh Surface 추가
- Bake 했는데 안 보임 : 우측 하단 AI Navigation > Surfaces > Show Navmesh 체크

#### Raycast 안됨
- 2D 프로젝트면 Physics2D.Raycast() 사용하기
- 렌더 텍스쳐를 Output Texture에 넣으면 마우스 Raycast 작동 안 함. 셰이더 쓰셈.

#### 머테리얼을 Transparent로 설정해도 살짝 불투명
셰이더를 Unlit으로 설정한다

#### 플레이어 이동에 약간 딜레이
Input.GetAxis 쓰면 딜레이 생긴다. Input.GetAxisRaw 쓰기.

#### 스프라이트 마스크 어떻게 씀?
Sprite Mask component may not be an issue. 
check Mask Interaction component on parent.

#### Camera.main이 null임
`Camera.main`은 "MainCamera" 태그가 붙은 카메라만 인식

#### DontDestroyOnLoad() 해도 사라짐
부모를 없애

#### 콜라이더가 분명 하나인데 더 달려있음
Character Controller에도 collider 달려있어서 그럼
굳이 콜라이더 추가할 필요 없음

#### Rigidbody 중력 작용 안 함
Character Controller 붙어있으면 Rigidbody 적용 안됨
`controller.Move(velocity * Time.deltaTime);` 이걸로 중력 구현하셈

#### sorting layer 바꿨더니 검은색 됨
global light 2d는 target sorting layer가 있어서 그걸 벗어나면 비춰주지 않는다

#### 위치 순간이동 로직 짰는데 순간이동 안 함
Character Controller는 내부 상태 유지 때문에 순간이동 무시함
순간이동 시킬 땐 enabled false 했다가 이동시키고 true하면 됨

#### fbx export 했는데 blender에서 인식 안돼
export format을 binary로 바꿔

#### font asset 한글 폰트인데 글자가 깨져
atlas width랑 height 늘려

### 🏷️ 스크립트

#### using Cinemachine이 안 먹힘
using Unity.Cinemachine 쓰셈

#### Trigger가 안됨
rigidbody 붙이셈

#### print()가 안됨
그거 MonoBehaviour랑 ScriptableObject에서만 됨.
대신 Debug.log() 쓰셈
내 코드 중에 Debug라는 이름 가진 클래스 있어도 안됨.

#### JsonUtility 불러오기가 안됨
JsonUtility는 최종적으로 감싸고 있는게 반드시 객체 (중괄호, `{}`)여야만 한다.
그래서 List여도 `Serialization<T>` 같은 클래스로 또 감싸야 함.

#### 동적 타입 둘을 비교하고 싶음
```cs
IComparable left = fieldValue as IComparable;
IComparable right = parsedCondValue as IComparable;

int result = left.CompareTo(right);

switch (cond.compFunc)
{
	case CompFunc.Same: return result == 0;
	case CompFunc.Diff: return result != 0;
```

`IComparable` 쓰셈


### 🏷️ Shader Graph

#### 2D Sprite Texture 연결했는데 전부 단색으로 나옴
Alpha 값도 연결하셈


### 🏷️ UI
#### 9-slice 적용 안됨
UI element의 Image - Image Type을 sliced로 바꾼다

### 🏷️ 협업
#### 깃 pull 할 때마다 메타파일 갱신
1. 애셋 직렬화 방식 : Project Settings - Editor - Asset Serialization - Force Text 통일
2. Project Settings - Editor - Version Control - Visible Meta Files 통일



## 🚀 최적화

- 퀄리티 차이 안 날 때까지 Texture의 Max Size 줄이기
- 중요하지 않은 물체는 Scale in Lightmap 줄이기

### 유나이트 서울 2020 - 최대 성능을 위한 최적화 팁

https://www.youtube.com/watch?v=tT9LS53HRx4

Script
- Object Pooling 써라
- 게임에서 변하지 않는 데이터를 위한 클래스 작성할 때 MonoBehaviour 말고 Scriptable Object 써라
- 프로퍼티 대신 그냥 변수 써라. 프로퍼티 사용하면 함수 호출하는 거라 특히 Update()같은 곳에서 잦은 호출할 때 안 좋다.
- Resources 폴더에 있는 리소스 많으면 앱 준비 시간에 나쁜 영향 준다. 가능하면 Addressable Assets 패키지의 AssetBundle 써라.
- Start()나 Update()같은 Unity 이벤트 함수는 비어 있으면 지워라. 비어있어도 선언돼있으면 매번 호출된다. 컴포넌트까지 같이 불려오기 때문에 느려진다.
  - release에선 별다른 구현 없지만 디버깅 용으로 사용한다면 define 분기로 최종 빌드에선 제외되게 해라.
- Awake(), Start()가 무거우면 Scene() 초기 동작을 지연시킨다. 초기화 로직 무거우면 Update()에서 별도의 FSM으로 초기화 구간을 구성해라.
- Hierarchy 복잡성 줄여라. Transform 구조들은 배열로 저장돼서 수정할 때마다 모든 배열 값 재설정. 가급적 Hiearchy 구조 변경도 하지 말기.
  - 계층적 구조가 필요한게 아니라면 Root에 GameObject를 배치하는게 성능면에서 가장 좋다.
- Find()는 모든 GameObject에 대해, GetComponent(), GetComponentInChildren()은 GameObject 내의 모든 컴포넌트에 대해 검사를 수행한다. 가능하면 미리 초기화 시점에 캐싱해둬라.
  - 검사 대상도 많고, 비교 검사 자체가 문자열 조건을 비교해서 오버헤드가 높다. 자주 사용하지 마라.

Texture Import Settings
- Generate Mipmaps : 밉맵 안 쓰면 꺼라. 리소스 용량 24% 감소.
- Format : (대부분은 자동으로 잘 압축) 디바이스에서 지원하는 압축 포맷 선택해야 무압축 대비 1/4 감소.
- 불필요한 알파 채널 삭제한다. 이미지 퀄리티 손실 조금 감소시켜줌.
- Read/Write Enable 해제한다. (기본값도 해제)

Mesh Import Settings
  - Mesh Compression : 원본과 안 달라지는 선에서 최대한 높은 압축 선택. Runtime 메모리는 영향 없지만 패키지 용량 감소.
  - Read/Write Enabled, Blendshapes, Normals and Tangents, Rig 등 사용 안하면 다 꺼라.

Audio Import Settings
- 스테레오 꼭 필요한 거 아니면 Force to Mono 사용
- 퀄리티 손상 체크하며 Compression bitrate 낮추기
- Audio Clip 크기 별 Load Type
  - 200kb 미만 : Decompress On Load
  - 200kb 이상 : Compressed In Memory
  - 1mb 이상 : Streaming
- Mute (볼륨 0) 상태에선 오디오 재생을 중지해라. 그리고 필요 없어지면 Audio Clip Unload해라.

Batching
  - 가능하면 같은 Texture / Material 써서 Batching 성공률 높여라. 아니면 Atlas Texture 써라.
  - Dynamic Batching 했는데 Batching 성공률 낮으면 그냥 꺼라.

Light
- 그림자 필요 없는 오브젝트는 Cast Shadow 꺼라.
- Light 효과 받는 대상은 별도 Layer로 구성해서 Culling Mask로 계산 비용 최소한으로 해라. Light(특히 Spot Light)는 계산 비용이 높다. 
- 보이지 않는 UI는 Activate 끄거나 Hide해라 . 카메라 밖으로 벗어나거나 다른 UI에 가려져도 실제로는 매 프레임마다 렌더링된다.

UI
- 정적인 UI와 동적인 UI를 분리시켜라. UI 변경 시 발생하는 UI Mesh 재생성 최소화할 수 있다.
- 하나의 Canvas에 있는 UI의 Z값을 동일하게 설정해라. Z값 다르면 Batching이 깨진다.
- Atlas를 활용하여 같은 머테리얼과 텍스쳐를 쓰게 해라.
- 동일한 Clipping Rect를 사용해라.
- 입력 이벤트 필요없으면 Graphic Raycaster 꺼라.
- Pause나 Main menu 띄울 때 전체 화면 불투명으로 가리는 UI 써라. Camera도 꺼서 렌더링 비용 줄여라.
- Frame Rate 낮춰라.

#### 플랫폼별 적절한 Tris(폴리곤) 개수 가이드라인  

| 플랫폼                                 | 권장 Tris 개수 (씬 전체 기준) | 최적화 필요 여부                 |
| ----------------------------------- | -------------------- | ------------------------- |
| 모바일 (Low-end, 보급형 기기)               | 100K ~ 300K          | ✅ 필수 (LOD + Occlusion)    |
| 모바일 (High-end, 플래그십 기기)             | 300K ~ 700K          | ⚠️ 일부 최적화 필요              |
| PC (Low-end, 내장그래픽, GTX 750 이하)     | 500K ~ 1M (100만)     | ✅ 필요 (LOD + Draw Call 감소) |
| PC (중급, GTX 1060 ~ 1660)            | 1M ~ 2M (200만)       | ⚠️ 적당한 최적화 필요             |
| PC (고급, RTX 3060 이상)                | 2M ~ 5M (500만)       | ❌ 최적화 크게 필요 없음            |
| PS4 / Xbox One                      | 1M ~ 2M (200만)       | ⚠️ 일부 최적화 필요              |
| PS5 / Xbox Series X                 | 3M ~ 10M (천만)        | ❌ 높은 처리 가능                |
| VR (Standalone, Quest 2)            | 100K ~ 500K          | ✅ 필수 (프레임 유지 필수)          |
| VR (PC VR, Valve Index, Quest Link) | 1M ~ 3M (300만)       | ⚠️ 약간의 최적화 필요             |

#### 씬 내 폴리곤 최적화

1️⃣ LOD(Level of Detail) 활용  
   - 가까운 오브젝트만 고해상도, 멀리 있는 건 저해상도로 자동 변경  
   - `LOD Group`을 활용해서 LOD 0 (높은 Tris) → LOD 3 (낮은 Tris) 설정

2️⃣ Occlusion Culling 활성화  
   - 카메라에 안 보이는 모델을 렌더링하지 않도록 최적화  
   - `Window > Rendering > Occlusion Culling`에서 적용

3️⃣ Batches / Draw Calls 최적화  
   - `Stats` 창에서 `SetPass Calls`가 많으면 병목 가능성 있음  
   - Mesh Combine + GPU Instancing을 적용해서 성능 개선

4️⃣ Shader & Material 최적화  
   - PBR 쉐이더 사용을 줄이고, Lightmap 사용으로 실시간 조명 연산을 줄이기  
   - 한 개의 머티리얼을 여러 개의 오브젝트에서 공유하면 드로우콜 감소

5️⃣ Dynamic Objects 줄이기  
   - 애니메이션이 적용된 오브젝트가 많으면 CPU 부하 증가  
   - `Static Batching`을 적용하면 정적인 오브젝트를 최적화할 수 있음



