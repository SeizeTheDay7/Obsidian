삼중 for문으로 모든 정점을 순회하면서
"나 거쳐서 갈 수 있는 놈들 있어? 싹 다 갱신해봐"

비용 상관없이 갈 수 있느냐 없느냐(이행적 폐쇄라고 함)만 따져보면

첫번째 for문 요소 : "나 A를 거쳐서"
두번째 for문 요소 : "B 너가"
세번째 for문 요소 : "C로 갈 수 있니?"

"나 A를 거쳐서, B 너가, C로 갈 수 있니?"

최소 비용 버전으로 보면

첫번째 for문 요소 : "나 A를 거쳐서 가는게"
두번째 for문 요소 : "B 너가"
세번째 for문 요소 : "C로 갈 때 더 빨리 가니?"

"나 A를 거쳐서 가는게, B 너가, C로 갈 때 더 빨리 가니?"


### 플로이드-와샬 알고리즘과 이행적 폐쇄

플로이드-와샬 알고리즘은 모든 정점 쌍 사이의 최단 경로를 찾는 알고리즘으로, 이를 통해 그래프의 최단 경로 문제를 해결할 수 있습니다. 이 알고리즘은 그래프의 이행적 폐쇄를 구하는 데도 사용됩니다.

### 이행적 폐쇄 (Transitive Closure)

이행적 폐쇄는 그래프의 모든 경로를 고려하여 두 정점 사이에 간접적인 경로가 있는 경우에도 직접적인 경로가 있다고 가정하는 것입니다. 예를 들어, 정점 A에서 B로, B에서 C로 가는 경로가 있다면, 이행적 폐쇄를 통해 A에서 C로 가는 경로가 있다고 가정합니다.

### 이행적 폐쇄 구하기

플로이드-와샬 알고리즘을 사용하여 이행적 폐쇄를 구할 수 있습니다. 그래프의 인접 행렬을 입력받아 각 정점 쌍에 대해 경로가 존재하는지를 확인하고, 이를 통해 이행적 폐쇄를 구합니다.

```python
# 무한대 값을 설정합니다
INF = float('inf')

# 그래프의 정점 수와 인접 행렬을 입력받습니다
n = int(input("Enter the number of vertices: "))
graph = []

print("Enter the adjacency matrix (use 0 for no edge and 1 for edge):")
for i in range(n):
    row = list(map(int, input().split()))
    graph.append(row)

# 플로이드-와샬 알고리즘을 이용한 이행적 폐쇄 구하기
def transitive_closure(graph):
    closure = list(map(lambda i: list(map(lambda j: j, i)), graph))
    for k in range(n):
        for i in range(n):
            for j in range(n):
                closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j])
    return closure

# 결과를 출력합니다
closure = transitive_closure(graph)

print("The transitive closure of the given graph:")
for i in range(n):
    for j in range(n):
        print(closure[i][j], end=" ")
    print()
```

### 설명

1. **그래프 입력**: 사용자로부터 정점 수와 인접 행렬을 입력받습니다.
2. **이행적 폐쇄 계산**:
   - `closure` 배열을 초기화하여 각 정점 쌍의 경로 유무를 저장합니다.
   - 3중 for 루프를 통해 모든 정점 쌍 사이의 경로 유무를 갱신합니다.
   - `closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j])`는 정점 `k`를 경유하여 `i`에서 `j`로 가는 경로가 있는지를 확인하여 갱신합니다.
3. **결과 출력**: 이행적 폐쇄를 출력합니다. 

이 코드는 주어진 그래프의 이행적 폐쇄를 계산하여 출력합니다.

플로이드-와샬 알고리즘을 사용하여 이행적 폐쇄를 계산하는 과정에서 각 단계를 찍어가며 설명하겠습니다. 

### 예제

먼저, 예제 그래프를 설정하겠습니다. 그래프는 인접 행렬로 표현됩니다. 

```
그래프 입력 예제:
4
0 1 0 0
0 0 1 0
0 0 0 1
0 0 0 0
```

위 예제는 4개의 정점을 가지며, 정점 간의 연결 상태를 나타냅니다. `0`은 연결되지 않았음을, `1`은 연결되었음을 의미합니다.

### 단계별 과정

1. **초기 그래프**:

   초기 상태의 그래프는 다음과 같습니다:

   ```
   0 1 0 0
   0 0 1 0
   0 0 0 1
   0 0 0 0
   ```

2. **k = 0** (첫 번째 정점을 중간에 사용할 경우):

   - **i = 0**:
     - **j = 0**: 0 or (0 and 0) = 0
     - **j = 1**: 1 or (0 and 1) = 1
     - **j = 2**: 0 or (0 and 0) = 0
     - **j = 3**: 0 or (0 and 0) = 0

   - **i = 1**:
     - **j = 0**: 0 or (0 and 0) = 0
     - **j = 1**: 0 or (0 and 1) = 0
     - **j = 2**: 1 or (0 and 0) = 1
     - **j = 3**: 0 or (0 and 0) = 0

   - **i = 2**:
     - **j = 0**: 0 or (0 and 0) = 0
     - **j = 1**: 0 or (0 and 0) = 0
     - **j = 2**: 0 or (0 and 1) = 0
     - **j = 3**: 1 or (0 and 0) = 1

   - **i = 3**:
     - **j = 0**: 0 or (0 and 0) = 0
     - **j = 1**: 0 or (0 and 0) = 0
     - **j = 2**: 0 or (0 and 0) = 0
     - **j = 3**: 0 or (0 and 0) = 0

   - 결과:

     ```
     0 1 0 0
     0 0 1 0
     0 0 0 1
     0 0 0 0
     ```

3. **k = 1** (두 번째 정점을 중간에 사용할 경우):

   - **i = 0**:
     - **j = 0**: 0 or (1 and 0) = 0
     - **j = 1**: 1 or (1 and 0) = 1
     - **j = 2**: 0 or (1 and 1) = 1
     - **j = 3**: 0 or (1 and 0) = 0

   - **i = 1**:
     - **j = 0**: 0 or (0 and 0) = 0
     - **j = 1**: 0 or (0 and 0) = 0
     - **j = 2**: 1 or (0 and 1) = 1
     - **j = 3**: 0 or (0 and 0) = 0

   - **i = 2**:
     - **j = 0**: 0 or (1 and 0) = 0
     - **j = 1**: 0 or (1 and 0) = 0
     - **j = 2**: 0 or (1 and 1) = 0
     - **j = 3**: 1 or (1 and 0) = 1

   - **i = 3**:
     - **j = 0**: 0 or (0 and 0) = 0
     - **j = 1**: 0 or (0 and 0) = 0
     - **j = 2**: 0 or (0 and 1) = 0
     - **j = 3**: 0 or (0 and 0) = 0

   - 결과:

     ```
     0 1 1 0
     0 0 1 0
     0 0 0 1
     0 0 0 0
     ```

4. **k = 2** (세 번째 정점을 중간에 사용할 경우):

   - **i = 0**:
     - **j = 0**: 0 or (1 and 0) = 0
     - **j = 1**: 1 or (1 and 0) = 1
     - **j = 2**: 1 or (1 and 1) = 1
     - **j = 3**: 0 or (1 and 1) = 1

   - **i = 1**:
     - **j = 0**: 0 or (0 and 0) = 0
     - **j = 1**: 0 or (0 and 0) = 0
     - **j = 2**: 1 or (0 and 1) = 1
     - **j = 3**: 0 or (0 and 1) = 1

   - **i = 2**:
     - **j = 0**: 0 or (0 and 0) = 0
     - **j = 1**: 0 or (0 and 0) = 0
     - **j = 2**: 0 or (0 and 0) = 0
     - **j = 3**: 1 or (0 and 1) = 1

   - **i = 3**:
     - **j = 0**: 0 or (1 and 0) = 0
     - **j = 1**: 0 or (1 and 0) = 0
     - **j = 2**: 0 or (1 and 1) = 0
     - **j = 3**: 0 or (1 and 1) = 0

   - 결과:

     ```
     0 1 1 1
     0 0 1 1
     0 0 0 1
     0 0 0 0
     ```

5. **k = 3** (네 번째 정점을 중간에 사용할 경우):

   - **i = 0**:
     - **j = 0**: 0 or (1 and 0) = 0
     - **j = 1**: 1 or (1 and 0) = 1
     - **j = 2**: 1 or (1 and 1) = 1
     - **j = 3**: 1 or (1 and 0) = 1

   - **i = 1**:
     - **j = 0**: 0 or (1 and 0) = 0
     - **j = 1**: 0 or (1 and 0) = 0
     - **j = 2**: 1 or (1 and 1) = 1
     - **j = 3**: 1 or (1 and 0) = 1

   - **i = 2**:
     - **j = 0**: 0 or (0 and 0) = 0
     - **j = 1**: 0 or (0 and 0) = 0
     - **j = 2**: 0 or (0 and 1) = 0
     - **j = 3**: 1 or (0 and 1) = 1

   - **i = 3**:
     - **j = 0**: 0 or (0 and 0) = 0
     - **j = 1**: 0 or (0 and 0) = 0
     - **j = 2**: 0 or (0 and 1) = 0
     - **j = 3**: 0 or (0 and 0) = 0

   - 결과:

     ```
     0 1 1 1
     0 0 1 1
     0 0 0 1
     0 0 0 0
     ```

최종 결과

### 플로이드-와샬 알고리즘을 사용한 이행적 폐쇄 구현

이 예제에서는 4개의 정점을 가지는 그래프를 사용하여 플로이드-와샬 알고리즘을 통해 이행적 폐쇄를 계산하는 과정을 단계별로 설명합니다.

```python
def transitive_closure(graph):
    n = len(graph)
    closure = list(map(lambda i: list(map(lambda j: j, i)), graph))
    for k in range(n):
        print(f"Intermediate closure matrix for k = {k}:")
        for row in closure:
            print(row)
        print()
        for i in range(n):
            for j in range(n):
                closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j])
    return closure

# 그래프 초기화
graph = [
    [0, 1, 0, 0],
    [0, 0, 1, 0],
    [0, 0, 0, 1],
    [0, 0, 0, 0]
]

# 이행적 폐쇄 계산
closure = transitive_closure(graph)

print("Final transitive closure of the given graph:")
for row in closure:
    print(row)
```

### 단계별 출력

1. **초기 그래프 상태**:
   ```
   0 1 0 0
   0 0 1 0
   0 0 0 1
   0 0 0 0
   ```

2. **k = 0 (정점 0을 중간 정점으로 사용)**:
   ```
   0 1 0 0
   0 0 1 0
   0 0 0 1
   0 0 0 0
   ```

3. **k = 1 (정점 1을 중간 정점으로 사용)**:
   ```
   0 1 1 0
   0 0 1 0
   0 0 0 1
   0 0 0 0
   ```

4. **k = 2 (정점 2를 중간 정점으로 사용)**:
   ```
   0 1 1 1
   0 0 1 1
   0 0 0 1
   0 0 0 0
   ```

5. **k = 3 (정점 3을 중간 정점으로 사용)**:
   ```
   0 1 1 1
   0 0 1 1
   0 0 0 1
   0 0 0 0
   ```

### 최종 결과
```
0 1 1 1
0 0 1 1
0 0 0 1
0 0 0 0
```

이 코드와 설명은 플로이드-와샬 알고리즘을 사용하여 그래프의 이행적 폐쇄를 계산하는 과정을 단계별로 출력하여 보여줍니다.