



### 1. **JSX (JavaScript XML)**
   - JSX는 JavaScript 내에서 HTML을 작성할 수 있도록 해주는 문법입니다. 실제로는 JavaScript로 변환되지만, 마치 HTML을 작성하는 것처럼 코드를 쓸 수 있습니다. 리액트 컴포넌트를 정의할 때 주로 JSX를 사용합니다.
   ```jsx
   const element = <h1>Hello, world!</h1>;
   ```

### 2. **컴포넌트 (Components)**
   - 리액트의 핵심은 컴포넌트입니다. 컴포넌트는 재사용 가능한 UI 요소를 정의하는 단위입니다. 각각의 컴포넌트는 독립적이며 자신의 상태와 라이프사이클을 가질 수 있습니다. 컴포넌트는 주로 함수 컴포넌트와 클래스 컴포넌트로 나뉩니다.

   **함수형 컴포넌트 (Function Component)**
   ```jsx
   function Welcome(props) {
     return <h1>Hello, {props.name}</h1>;
   }
   ```

   **클래스형 컴포넌트 (Class Component)**
   ```jsx
   class Welcome extends React.Component {
     render() {
       return <h1>Hello, {this.props.name}</h1>;
     }
   }
   ```

### 3. **프롭스 (Props)**
   - 프롭스는 부모 컴포넌트가 자식 컴포넌트에 전달하는 데이터를 의미합니다. 프롭스는 읽기 전용으로, 자식 컴포넌트에서 변경할 수 없습니다.
   ```jsx
   function Welcome(props) {
     return <h1>Hello, {props.name}</h1>;
   }
   ```

### 4. **상태 (State)**
   - 컴포넌트는 상태를 통해 데이터나 UI의 동적 변화를 관리합니다. 클래스형 컴포넌트에서는 `this.state`를 사용하고, 함수형 컴포넌트에서는 `useState` 훅을 사용합니다.

   **클래스형 컴포넌트에서의 상태**
   ```jsx
   class Clock extends React.Component {
     constructor(props) {
       super(props);
       this.state = {date: new Date()};
     }
   }
   ```

   **함수형 컴포넌트에서의 상태 (useState 훅)**
   ```jsx
   import { useState } from 'react';

   function Example() {
     const [count, setCount] = useState(0);
     return (
       <div>
         <p>You clicked {count} times</p>
         <button onClick={() => setCount(count + 1)}>Click me</button>
       </div>
     );
   }
   ```

### 5. **훅 (Hooks)**
   - 함수형 컴포넌트에서 상태와 생명주기 메서드를 사용할 수 있도록 하는 기능입니다. 가장 많이 사용되는 훅은 `useState`와 `useEffect`입니다.
   
   **useEffect 훅**
   ```jsx
   import { useState, useEffect } from 'react';

   function Example() {
     const [count, setCount] = useState(0);

     useEffect(() => {
       document.title = `You clicked ${count} times`;
     }, [count]);

     return (
       <div>
         <p>You clicked {count} times</p>
         <button onClick={() => setCount(count + 1)}>Click me</button>
       </div>
     );
   }
   ```

### 6. **생명주기 메서드 (Lifecycle Methods)**
   - 리액트 컴포넌트가 생성, 업데이트, 소멸되는 과정을 제어하는 메서드입니다. 클래스형 컴포넌트에서는 `componentDidMount`, `componentDidUpdate`, `componentWillUnmount` 등을 사용하고, 함수형 컴포넌트에서는 `useEffect` 훅을 이용합니다.

### 7. **컨텍스트 (Context)**
   - 컨텍스트는 컴포넌트 트리 전체에 데이터를 전달할 수 있도록 해주는 기능입니다. 일반적으로 부모에서 자식으로 프롭스를 전달하는 방식 대신, 전역적으로 데이터를 관리하고 싶을 때 유용합니다.

   ```jsx
   const ThemeContext = React.createContext('light');

   function App() {
     return (
       <ThemeContext.Provider value="dark">
         <Toolbar />
       </ThemeContext.Provider>
     );
   }
   ```

### 8. **리액트 라우터 (React Router)**
   - 리액트는 SPA(Single Page Application)를 위한 라이브러리이기 때문에, URL에 따른 컴포넌트 전환을 쉽게 해주는 리액트 라우터가 자주 사용됩니다.
   ```jsx
   import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';

   function App() {
     return (
       <Router>
         <Switch>
           <Route path="/about">
             <About />
           </Route>
           <Route path="/">
             <Home />
           </Route>
         </Switch>
       </Router>
     );
   }
   ```

### 9. **리덕스 (Redux)와 상태 관리**
   - 리액트 자체로 상태 관리를 할 수 있지만, 애플리케이션이 커질수록 복잡해지기 때문에 전역 상태 관리 도구인 리덕스(Redux)를 사용하는 경우가 많습니다. Redux는 전역 상태를 관리하는 스토어(store)를 사용하여 데이터의 흐름을 중앙에서 제어합니다.

### 10. **리액트 최적화 기법**
   - 리액트는 기본적으로 필요한 곳에서만 렌더링을 하지만, 성능 최적화를 위해 `React.memo`나 `useMemo`, `useCallback` 같은 기법을 사용하여 불필요한 렌더링을 방지할 수 있습니다.

리액트의 중요한 개념에 이어, 좀 더 심화된 개념들과 기술들을 소개할게요.

### 11. **합성(Composition)과 상속(Inheritance)**
   - 리액트는 합성을 통해 컴포넌트 간의 관계를 관리하는 것을 권장합니다. 합성은 컴포넌트를 서로 중첩하거나 결합하여 재사용성을 높이는 방식입니다. 상속보다는 합성을 통해 컴포넌트를 확장하는 것이 일반적입니다.

   **합성의 예시 (Props.children 사용)**
   ```jsx
   function FancyBorder(props) {
     return (
       <div className={'FancyBorder FancyBorder-' + props.color}>
         {props.children}
       </div>
     );
   }

   function WelcomeDialog() {
     return (
       <FancyBorder color="blue">
         <h1 className="Dialog-title">Welcome</h1>
         <p className="Dialog-message">Thank you for visiting our spacecraft!</p>
       </FancyBorder>
     );
   }
   ```

### 12. **고차 컴포넌트(Higher-Order Components, HOC)**
   - 고차 컴포넌트는 컴포넌트를 받아들이고, 새로운 컴포넌트를 반환하는 패턴입니다. HOC는 컴포넌트의 로직을 재사용할 때 유용합니다.
   
   ```jsx
   function withLogging(WrappedComponent) {
     return class extends React.Component {
       componentDidMount() {
         console.log('Component did mount');
       }

       render() {
         return <WrappedComponent {...this.props} />;
       }
     };
   }
   ```

### 13. **렌더링 방식 (Rendering Types)**
   - **CSR(Client-Side Rendering)**: 리액트는 기본적으로 클라이언트에서 렌더링합니다. 모든 렌더링 로직이 브라우저에서 실행되며, 초기 로드 시 빈 HTML 파일을 가져오고, 자바스크립트가 로드되면 UI가 그려집니다.
   - **SSR(Server-Side Rendering)**: 서버에서 HTML을 렌더링하여 클라이언트에 전달하는 방식입니다. Next.js와 같은 프레임워크가 SSR을 지원합니다.
   - **SSG(Static Site Generation)**: 빌드 시점에 HTML을 생성하고, 그 결과물을 정적 파일로 배포하는 방식입니다.
   - **ISR(Incremental Static Regeneration)**: SSG에서 일부 페이지를 동적으로 다시 생성하여 캐시를 업데이트하는 방식입니다.

### 14. **리액트의 비동기 처리**
   - 리액트에서 비동기 처리는 주로 `useEffect` 안에서 API 호출 등을 처리합니다. `async/await`나 `Promise`를 사용하여 데이터를 가져올 수 있습니다.
   ```jsx
   import { useEffect, useState } from 'react';

   function DataFetcher() {
     const [data, setData] = useState(null);

     useEffect(() => {
       async function fetchData() {
         const response = await fetch('https://api.example.com/data');
         const result = await response.json();
         setData(result);
       }
       fetchData();
     }, []);

     return <div>{data ? data.name : 'Loading...'}</div>;
   }
   ```

### 15. **리액트의 최적화 기법**
   - 리액트에서 성능 최적화는 큰 애플리케이션에서 중요한 부분입니다. 기본적으로 리액트는 필요한 부분만 렌더링하지만, 성능 최적화를 위해 다양한 방법을 사용할 수 있습니다.
     - **React.memo**: 컴포넌트가 동일한 프롭스를 받으면 재렌더링하지 않도록 최적화합니다.
     - **useMemo**: 값이 바뀔 때만 함수를 실행하고, 그 외의 경우에는 메모이제이션된 값을 반환합니다.
     - **useCallback**: 함수 자체를 메모이제이션하여 불필요한 재생성을 방지합니다.

   **React.memo 사용 예시**
   ```jsx
   const MyComponent = React.memo(function MyComponent(props) {
     /* 렌더링 로직 */
   });
   ```

   **useMemo 사용 예시**
   ```jsx
   const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
   ```

   **useCallback 사용 예시**
   ```jsx
   const memoizedCallback = useCallback(() => {
     doSomething(a, b);
   }, [a, b]);
   ```

### 16. **Reconciliation과 Virtual DOM**
   - 리액트는 성능을 높이기 위해 "Virtual DOM"이라는 개념을 사용합니다. Virtual DOM은 실제 DOM의 가벼운 사본을 만들고, 상태가 변경될 때마다 비교(diff)하여 필요한 부분만 업데이트하는 방식입니다. 이를 통해 불필요한 렌더링을 줄이고 성능을 최적화합니다.

### 17. **Portals**
   - 포탈은 리액트 컴포넌트를 현재의 부모 컴포넌트 외부에 렌더링할 수 있도록 합니다. 일반적으로 모달, 팝업, 툴팁 등의 UI를 구현할 때 사용됩니다.

   ```jsx
   import ReactDOM from 'react-dom';

   function Modal({ children }) {
     return ReactDOM.createPortal(
       <div className="modal">{children}</div>,
       document.getElementById('modal-root')
     );
   }
   ```

### 18. **프래그먼트(Fragments)**
   - 프래그먼트는 불필요한 추가 노드 없이 여러 자식을 그룹화할 때 사용됩니다. JSX에서 컴포넌트의 부모 요소는 하나만 존재해야 하기 때문에, 여러 요소를 반환해야 할 때 프래그먼트를 사용합니다.
   
   ```jsx
   function List() {
     return (
       <>
         <li>Item 1</li>
         <li>Item 2</li>
         <li>Item 3</li>
       </>
     );
   }
   ```

### 19. **Strict Mode**
   - 리액트에서 `StrictMode`는 애플리케이션의 잠재적 문제를 감지하는 개발 도구입니다. Strict Mode는 실제 동작에 영향을 주지 않으며, 오직 개발 모드에서만 동작합니다.
   
   ```jsx
   <React.StrictMode>
     <App />
   </React.StrictMode>
   ```

### 20. **실제 DOM 접근 (Refs)**
   - `ref`는 리액트에서 직접 DOM 요소에 접근할 때 사용됩니다. 일반적으로 DOM을 직접 조작하는 것은 권장되지 않지만, 특정 상황에서는 필요할 수 있습니다.
   
   ```jsx
   import { useRef } from 'react';

   function TextInputWithFocusButton() {
     const inputEl = useRef(null);
     const onButtonClick = () => {
       inputEl.current.focus();
     };
     return (
       <>
         <input ref={inputEl} type="text" />
         <button onClick={onButtonClick}>Focus the input</button>
       </>
     );
   }
   ```

리액트는 유연하고 모듈화된 아키텍처 덕분에 다양한 방법으로 사용될 수 있습니다. 위의 개념들을 바탕으로 프로젝트를 효율적으로 관리하고, 성능을 최적화할 수 있습니다.

리액트는 매우 다양한 기능과 개념을 가지고 있어, 여러 층위에서 더 깊게 다룰 수 있는 주제들이 많습니다. 이번에는 더 고급 개념과 리액트 생태계에서 자주 사용되는 도구들에 대해 설명할게요.

### 21. **서스펜스(Suspense)와 코드 스플리팅(Code Splitting)**
   - 리액트에서 서스펜스는 비동기적으로 데이터나 컴포넌트를 로드할 때, UI의 로딩 상태를 처리하는 메커니즘입니다. `React.lazy`와 함께 코드 스플리팅을 할 수 있어, 페이지 로딩 시에 필요한 코드만 로드하는 최적화를 제공합니다.

   **코드 스플리팅 예시**
   ```jsx
   import React, { Suspense } from 'react';

   const OtherComponent = React.lazy(() => import('./OtherComponent'));

   function MyComponent() {
     return (
       <div>
         <Suspense fallback={<div>Loading...</div>}>
           <OtherComponent />
         </Suspense>
       </div>
     );
   }
   ```

   - `React.lazy`는 코드 스플리팅을 가능하게 하여 애플리케이션을 더 가볍게 만들어줍니다. `Suspense`는 그동안의 로딩 상태를 다루는 역할을 합니다.

### 22. **Concurrent Mode (동시성 모드)**
   - 리액트는 사용자 인터페이스의 응답성을 높이기 위해 동시성 모드를 도입했습니다. 동시성 모드는 컴포넌트를 동시에 렌더링할 수 있게 하여 성능을 극대화합니다.
   - 아직 실험적인 기능이지만, 사용자 경험을 향상시키기 위한 중요한 발전입니다. 이 모드는 리액트가 여러 작업을 분할해 처리할 수 있도록 하여, 사용자 인터페이스가 느려지는 것을 방지합니다.

### 23. **useTransition과 useDeferredValue**
   - 리액트에서 동시성을 처리하는 훅입니다. `useTransition`은 느린 상태 업데이트를 다룰 때, 사용자 인터페이스를 부드럽게 전환할 수 있도록 도와줍니다.
   
   **useTransition 사용 예시**
   ```jsx
   import { useState, useTransition } from 'react';

   function App() {
     const [isPending, startTransition] = useTransition();
     const [count, setCount] = useState(0);

     function handleClick() {
       startTransition(() => {
         setCount(count + 1);
       });
     }

     return (
       <>
         {isPending ? <p>Loading...</p> : <p>{count}</p>}
         <button onClick={handleClick}>Increment</button>
       </>
     );
   }
   ```

   - `useDeferredValue`는 고비용의 상태 업데이트를 지연시켜, 더 긴급한 작업들이 먼저 실행될 수 있도록 도와줍니다. 이것은 검색 입력 상자 같은 컴포넌트에서 유용할 수 있습니다.

### 24. **React Context와 전역 상태 관리**
   - 리액트에서 `Context`는 컴포넌트 트리 전체에 데이터를 전달하는 데 사용되며, 전역적으로 데이터를 공유할 수 있게 도와줍니다. 하지만 상태가 복잡해지면 `Context`는 관리가 어려울 수 있어 리덕스(Redux)나 다른 전역 상태 관리 도구와 결합하여 사용합니다.
   
   **Context 사용 예시**
   ```jsx
   const ThemeContext = React.createContext('light');

   function App() {
     return (
       <ThemeContext.Provider value="dark">
         <Toolbar />
       </ThemeContext.Provider>
     );
   }

   function Toolbar() {
     return <ThemedButton />;
   }

   function ThemedButton() {
     const theme = React.useContext(ThemeContext);
     return <button className={theme}>Theme Button</button>;
   }
   ```

### 25. **리덕스(Redux)와 MobX**
   - **리덕스**: 리덕스는 상태 관리를 위한 가장 널리 사용되는 라이브러리입니다. 전역 상태를 관리하기 위해 `store`를 사용하고, 상태를 변경하기 위한 액션(action)과 리듀서(reducer)를 정의합니다. 상태 변경은 항상 순수 함수인 리듀서를 통해 이루어지며, `dispatch`를 통해 액션을 전송합니다.
   
   **리덕스 사용 예시**
   ```js
   const initialState = { value: 0 };

   function counterReducer(state = initialState, action) {
     switch (action.type) {
       case 'increment':
         return { value: state.value + 1 };
       default:
         return state;
     }
   }

   const store = createStore(counterReducer);

   store.dispatch({ type: 'increment' });
   console.log(store.getState()); // { value: 1 }
   ```

   - **MobX**: MobX는 반응형 상태 관리 라이브러리로, 자동으로 상태 변경을 감지하여 UI를 업데이트하는 기능을 제공합니다. 상태 변경이 즉시 UI에 반영되므로 코드가 간결하고 사용하기 쉬운 장점이 있습니다.

### 26. **Form 관리**
   - 리액트에서 폼 처리는 매우 중요한 부분입니다. 리액트는 상태 기반이므로, 폼 입력값을 상태로 관리하여 UI를 제어할 수 있습니다. 추가로 `Formik`, `React Hook Form`과 같은 라이브러리는 복잡한 폼 처리와 유효성 검사를 보다 쉽게 처리할 수 있게 도와줍니다.

   **React Hook Form 예시**
   ```jsx
   import { useForm } from 'react-hook-form';

   function MyForm() {
     const { register, handleSubmit } = useForm();
     const onSubmit = data => console.log(data);

     return (
       <form onSubmit={handleSubmit(onSubmit)}>
         <input {...register("firstName")} />
         <input type="submit" />
       </form>
     );
   }
   ```

### 27. **테스트 (Testing)**
   - 리액트 애플리케이션에서 테스트는 중요한 부분입니다. 다음은 자주 사용되는 테스트 도구들입니다:
     - **Jest**: 페이스북에서 개발한 JavaScript 테스트 프레임워크로, 리액트 애플리케이션 테스트에 자주 사용됩니다.
     - **React Testing Library**: 리액트 컴포넌트를 테스트하기 위한 도구로, 사용자 관점에서 컴포넌트를 테스트하는 것을 목표로 합니다.
     - **Cypress**: E2E(End-to-End) 테스트 도구로, 사용자 관점에서 전체 애플리케이션을 테스트할 수 있습니다.

   **Jest 및 React Testing Library 사용 예시**
   ```jsx
   import { render, screen } from '@testing-library/react';
   import App from './App';

   test('renders learn react link', () => {
     render(<App />);
     const linkElement = screen.getByText(/learn react/i);
     expect(linkElement).toBeInTheDocument();
   });
   ```

### 28. **프로젝트 구조**
   - 리액트 프로젝트는 일반적으로 폴더 구조를 체계적으로 관리하는 것이 중요합니다. 대표적으로 **"Atomic Design"** 패턴이 많이 사용되며, 컴포넌트를 기능적 혹은 계층적으로 나누는 방식입니다.
     - **Atoms**: 기본적인 UI 요소 (버튼, 입력 필드 등)
     - **Molecules**: 간단한 컴포넌트의 집합 (입력 필드와 레이블)
     - **Organisms**: 복잡한 UI 요소들 (헤더, 폼 등)
     - **Templates**: 페이지 레이아웃
     - **Pages**: 실제 화면 구성
   
   **예시 프로젝트 구조**
   ```
   src/
     components/
       atoms/
       molecules/
       organisms/
     pages/
     hooks/
     contexts/
     utils/
     App.js
     index.js
   ```

### 29. **React Native**
   - 리액트는 웹 애플리케이션뿐만 아니라 **React Native**를 통해 모바일 애플리케이션도 개발할 수 있습니다. 리액트와 동일한 개념을 사용하며, iOS 및 Android 앱을 동시에 개발할 수 있는 장점이 있습니다.

### 30. **CSS-in-JS**
   - CSS 관리도 리액트에서 중요한 부분입니다. **Styled-components**와 같은 CSS-in-JS 라이브러리는 컴포넌트 내에서 스타일을 작성할 수 있게 해줍니다. 이렇게 하면 CSS 범위가 컴포넌트 단위로 격리되므로, 전역 CSS 충돌을 방지할 수 있습니다.

   **Styled-components 사용 예시**
   ```jsx
   import styled from 'styled-components';

   const Button = styled.button`
     background: palevioletred;
     color: white;
     font-size: 1em;
     padding: 0.25em 1em;
     border-radius: 3px;
   `;

   function App() {
     return <Button>Click me</Button>;
   }
   ```

리액트는 계속해서 발전하고 있으며, 그 생태계도 매우 넓습니다. 각종 라이브러리와 도구들을

 상황에 맞게 활용하여 더 효율적이고 유지보수가 쉬운 애플리케이션을 개발할 수 있습니다. 이 개념들을 기반으로 리액트 프로젝트를 좀 더 깊게 다룰 수 있게 될 것입니다.