- [[#📌 Tip|📌 Tip]]
	- [[#📌 Tip#🏷️ Visual Studio|🏷️ Visual Studio]]
- [[#📌 개념|📌 개념]]
	- [[#📌 개념#🏷️ 전역 변수와 지역 변수|🏷️ 전역 변수와 지역 변수]]
	- [[#📌 개념#🏷️ 네임스페이스|🏷️ 네임스페이스]]
	- [[#📌 개념#🏷️ 메서드|🏷️ 메서드]]
		- [[#🏷️ 메서드#메서드의 매개변수 전달 방식|메서드의 매개변수 전달 방식]]
		- [[#🏷️ 메서드#ref와 out의 차이|ref와 out의 차이]]
	- [[#📌 개념#🏷️ 필드|🏷️ 필드]]
	- [[#📌 개념#🏷️ 액세스 한정자|🏷️ 액세스 한정자]]
	- [[#📌 개념#🏷️ 생성자|🏷️ 생성자]]
		- [[#🏷️ 생성자#정적 생성자 (static constructor)|정적 생성자 (static constructor)]]
		- [[#🏷️ 생성자#인스턴스 생성자 (public constructor)|인스턴스 생성자 (public constructor)]]
		- [[#🏷️ 생성자#정적 생성자만 있을 때의 동작|정적 생성자만 있을 때의 동작]]
		- [[#🏷️ 생성자#생성자 포워딩|생성자 포워딩]]
		- [[#🏷️ 생성자#생성자를 사용하여 읽기 전용 필드 초기화|생성자를 사용하여 읽기 전용 필드 초기화]]
	- [[#📌 개념#🏷️ 소멸자|🏷️ 소멸자]]
	- [[#📌 개념#🏷️ 프로퍼티|🏷️ 프로퍼티]]
	- [[#📌 개념#🏷️ 상속 가능한 접근 제한자|🏷️ 상속 가능한 접근 제한자]]
- [[#📌 자료형|📌 자료형]]
	- [[#📌 자료형#🏷️ 기본 자료형 모음|🏷️ 기본 자료형 모음]]
	- [[#📌 자료형#🏷️ 자료형 변환|🏷️ 자료형 변환]]
	- [[#📌 자료형#🏷️ const : 상수 선언|🏷️ const : 상수 선언]]
	- [[#📌 자료형#🏷️ float|🏷️ float]]
	- [[#📌 자료형#🏷️ var : 아무거나 넣어도 됨|🏷️ var : 아무거나 넣어도 됨]]
	- [[#📌 자료형#🏷️ 배열|🏷️ 배열]]
		- [[#🏷️ 배열#Rank, Length, GetLength()|Rank, Length, GetLength()]]
		- [[#🏷️ 배열#가변 배열|가변 배열]]
	- [[#📌 자료형#🏷️ 리스트|🏷️ 리스트]]
	- [[#📌 자료형#🏷️ struct : 구조체|🏷️ struct : 구조체]]
		- [[#🏷️ struct : 구조체#DateTime : 시간/날짜 정보|DateTime : 시간/날짜 정보]]
		- [[#🏷️ struct : 구조체#TimeSpan : 시간/날짜 간격|TimeSpan : 시간/날짜 간격]]
	- [[#📌 자료형#🏷️ Guid|🏷️ Guid]]
	- [[#📌 자료형#🏷️ enum : 열거형|🏷️ enum : 열거형]]
	- [[#📌 자료형#🏷️ TryParse() : 변환 시도하고 안되면 기본값|🏷️ TryParse() : 변환 시도하고 안되면 기본값]]
	- [[#📌 자료형#🏷️ GetType() : 자료형 확인|🏷️ GetType() : 자료형 확인]]
	- [[#📌 자료형#🏷️ 자료형 기본값으로 초기화|🏷️ 자료형 기본값으로 초기화]]
	- [[#📌 자료형#🏷️ 제네릭|🏷️ 제네릭]]
		- [[#🏷️ 제네릭#제네릭 타입 제약|제네릭 타입 제약]]
		- [[#🏷️ 제네릭#Dictionary 제네릭 클래스|Dictionary 제네릭 클래스]]
	- [[#📌 자료형#🏷️ Enumerable 클래스 : 특정 범위의 정수 컬렉션 만들기|🏷️ Enumerable 클래스 : 특정 범위의 정수 컬렉션 만들기]]
	- [[#📌 자료형#🏷️ `Nullable<T>` 형식 : 값형 변수에도 null 할당 가능|🏷️ `Nullable<T>` 형식 : 값형 변수에도 null 할당 가능]]
- [[#📌 문법|📌 문법]]
	- [[#📌 문법#🏷️ 변수 선언 방식|🏷️ 변수 선언 방식]]
	- [[#📌 문법#🏷️ 전위 연산자, 후위 연산자|🏷️ 전위 연산자, 후위 연산자]]
	- [[#📌 문법#🏷️ 삼항 연산자|🏷️ 삼항 연산자]]
	- [[#📌 문법#🏷️ 제어문 종류 : if, while, goto 등|🏷️ 제어문 종류 : if, while, goto 등]]
	- [[#📌 문법#🏷️ 조건문|🏷️ 조건문]]
		- [[#🏷️ 조건문#Switch 문|Switch 문]]
	- [[#📌 문법#🏷️ 반복문|🏷️ 반복문]]
		- [[#🏷️ 반복문#for문|for문]]
		- [[#🏷️ 반복문#do while|do while]]
		- [[#🏷️ 반복문#foreach|foreach]]
	- [[#📌 문법#🏷️ 기타 제어문|🏷️ 기타 제어문]]
		- [[#🏷️ 기타 제어문#goto|goto]]
	- [[#📌 문법#🏷️ 문자열 입력|🏷️ 문자열 입력]]
	- [[#📌 문법#🏷️ Console.WriteLine() : 명령줄 출력|🏷️ Console.WriteLine() : 명령줄 출력]]
	- [[#📌 문법#🏷️ ?. 연산자 : null 체크하며 멤버나 메서드 접근|🏷️ ?. 연산자 : null 체크하며 멤버나 메서드 접근]]
	- [[#📌 문법#🏷️ ?? 연산자 : 왼쪽 항 null이면 반환, 아니면 오른쪽 반환|🏷️ ?? 연산자 : 왼쪽 항 null이면 반환, 아니면 오른쪽 반환]]
	- [[#📌 문법#🏷️ 튜플 리터럴|🏷️ 튜플 리터럴]]
	- [[#📌 문법#🏷️ nameof() : 클래스, 메서드 이름을 문자열로 가져오기|🏷️ nameof() : 클래스, 메서드 이름을 문자열로 가져오기]]
	- [[#📌 문법#🏷️ throw : 예외 발생시키기|🏷️ throw : 예외 발생시키기]]
		- [[#🏷️ throw : 예외 발생시키기#throw와 throw ex의 차이|throw와 throw ex의 차이]]
	- [[#📌 문법#🏷️ 내장 클래스|🏷️ 내장 클래스]]
		- [[#🏷️ 내장 클래스#String 클래스 메서드 정리|String 클래스 메서드 정리]]
		- [[#🏷️ 내장 클래스#StringBuilder 클래스 : 더 빠른 문자열|StringBuilder 클래스 : 더 빠른 문자열]]
	- [[#📌 문법#🏷️ LINQ|🏷️ LINQ]]
		- [[#🏷️ LINQ#화살표 함수 (람다식) : 메서드 코드 줄이기|화살표 함수 (람다식) : 메서드 코드 줄이기]]
		- [[#🏷️ LINQ#Where() 메서드 : 조건식을 만족하는 컬렉션|Where() 메서드 : 조건식을 만족하는 컬렉션]]
		- [[#🏷️ LINQ#All() 메서드 : 조건식 모두 만족하는지|All() 메서드 : 조건식 모두 만족하는지]]
		- [[#🏷️ LINQ#Any() 메서드 : 조건식 하나라도 만족하는지|Any() 메서드 : 조건식 하나라도 만족하는지]]
		- [[#🏷️ LINQ#Take() 메서드 : 지정한 개수만큼 데이터 가져오기|Take() 메서드 : 지정한 개수만큼 데이터 가져오기]]
		- [[#🏷️ LINQ#Skip() : 지정한 수만큼 데이터를 제외한 컬렉션 반환|Skip() : 지정한 수만큼 데이터를 제외한 컬렉션 반환]]
		- [[#🏷️ LINQ#Distinct() : 중복 제거하기|Distinct() : 중복 제거하기]]
		- [[#🏷️ LINQ#OrderBy() : 오름차순 정렬|OrderBy() : 오름차순 정렬]]
		- [[#🏷️ LINQ#OrderByDescending() : 내림차순 정렬|OrderByDescending() : 내림차순 정렬]]
		- [[#🏷️ LINQ#Single()과 SingleOrDefault() : 조건에 맞는 값을 하나 가져오기|Single()과 SingleOrDefault() : 조건에 맞는 값을 하나 가져오기]]
		- [[#🏷️ LINQ#First()와 FirstOrDefault() : 첫 번째 요소 반환|First()와 FirstOrDefault() : 첫 번째 요소 반환]]
		- [[#🏷️ LINQ#Select() : 특정 속성만 뽑아내거나, 데이터 형태 변환|Select() : 특정 속성만 뽑아내거나, 데이터 형태 변환]]
		- [[#🏷️ LINQ#ForEach() : 반복문 돌리기|ForEach() : 반복문 돌리기]]
	- [[#📌 문법#🏷️ virtual, override : 상속 시 재정의|🏷️ virtual, override : 상속 시 재정의]]
	- [[#📌 문법#🏷️ abstract : 부모 클래스에서 구현 없는 메서드|🏷️ abstract : 부모 클래스에서 구현 없는 메서드]]
- [[#📌 구현|📌 구현]]
	- [[#📌 구현#🏷️ 특정 문자열을 포함하는 컬렉션 가져오기|🏷️ 특정 문자열을 포함하는 컬렉션 가져오기]]
	- [[#📌 구현#🏷️ 여러 문자열 합쳐서 출력하는 방법들|🏷️ 여러 문자열 합쳐서 출력하는 방법들]]
	- [[#📌 구현#🏷️ 메서드 이름 간단하게 줄여서 쓰는 방법|🏷️ 메서드 이름 간단하게 줄여서 쓰는 방법]]



## 📌 Tip
---

**vscode에서 C# 컴파일**
dotnet new console 하면 프로젝트 생성
dotnet run 하면 실행

**C# 특징**
- 대소문자를 구분
- 공백이나 줄 바꿈은 무시

```C#
int number = 1_000_000;
```
세 자리마다 콤마로 구분되는 긴 형태를 표현할 수 있다

**@ 기호로 여러 줄 문자열 저장할 수 있다**
``` c#
string multiLines = @"
	안녕하세요,
	반갑습니다.
	";
```

### 🏷️ Visual Studio

**시작 개체 설정**
프로그램 하나에 클래스 이름이 다른 Main() 메서드 여러 개를 넣을 수 있다.
원하는 Main() 메서드를 시작 개체로 설정: 우클릭 > 상황 > 속성 > 시작 개체 변경

**`<summary>` 자동 생성**
클래스나 속성 위에서 `///`을 입력하면 자동으로 생성

**코드 조각 자동 생성**
svm + Tab Tab
cw + Tab Tab 
if + Tab Tab
else + Tab Tab
for + Tab Tab


## 📌 개념
---

### 🏷️ 전역 변수와 지역 변수
전역 변수, 필드 : 클래스와 같은 레벨에서 선언된 변수
지역 변수 : 함수 레벨에서 선언된 변수

동일한 이름으로 전역 변수와 지역 변수를 같이 선언할 수 있다.
함수 내에서는 지역 변수를 쓰고, 지역 변수가 없으면 전역 변수를 쓴다.

C#에서는 전역 변수가 아닌 필드라는 단어를 주로 사용하며,
전역 변수는 언더스코어(`_`) 또는 `m_` 접두사를 붙이는 경향이 있다.

### 🏷️ 네임스페이스
```cs
namespace 네임스페이스이름
{
	// 클래스 등의 정의가 들어옴
}
```
네임스페이스는 프로그램 규모가 커질 때 클래스 이름이 충돌하는 것을 방지하도록 클래스를 모아서 관리하는 개념이다.
네임스페이스를 달리하면 이름이 동일한 클래스를 하나의 프로젝트에서 사용할 수 있다.

```cs
namespace AllCar
{
	namespace MyCar {}
    namespace YourCar {}
}
```
네임스페이스는 중첩하여 사용할 수 있다.

```cs
using System;
using MyNamespace;
using AllCar.MyCar; // 계층형 네임스페이스
using Fe = AllCar.Ferrari; // 별칭 붙이기
```
네임스페이스 사용하려면 using으로 선언해놔야 한다.

### 🏷️ 메서드
C# 에서는 모든 함수를 클래스 내에 선언하기 때문에,
함수 대신에 메서드라고 한다.
#### 메서드의 매개변수 전달 방식
- 값 전달 방식: 말 그대로 매개변수로 값을 그대로 복사해서 전달
- 참조 전달 방식(ref): 실제 데이터는 매개변수가 선언된 쪽에서만 저장하고, 호출된 메서드에서는 참조만 하는 형태로 변수 이름만 전달
- 반환형 전달 방식(out): 메서드를 호출하는 쪽에서 선언만 하고, 초기화하지 않고 전달하면 메서드 쪽에서 해당 데이터를 초기화해서 넘겨주는 방식
- 가변형 전달 방식(params): 매개 변수 여러 개를 배열형으로 받을 때 `params` 키워드를 붙인다. 가변 길이 매개변수는 매개변수를 선언할 때 반드시 마지막에 위치해야 함.
#### ref와 out의 차이
- ref: 메서드 호출 전에 반드시 변수 초기화해야 함. 
  입력으로도 사용되기 때문에 기존 값을 변경할 수 있다는 의미를 가짐.
- out: 메서드 호출 전에 초기화 안 해도 되고, 메서드 안에선 반드시 초기화해야 함.
  출력 전용이므로 초기값은 중요하지 않고, 메서드 내부에서 값을 설정해서 반환하겠다는 의미를 가짐.

### 🏷️ 필드
클래스 내에 선언된 필드는 자동으로 해당 형식의 기본값으로 초기화된다.
- 정수형(int, long, byte, short) : 0
- 실수형(float, double) : 0.0 
- 불형 : false
- 기타 참조형(reference type) : null

### 🏷️ 액세스 한정자
- public : 모든 곳에서 접근 가능
- private : 현재 클래스 내에서만 접근 가능
- protected : 현재 클래스 또는 현재 클래스를 상속하는 자식 클래스에만 접근이 허가됨
- internal : 현재 프로젝트의 모든 클래스에 접근이 허가됨
- protected internal : 현재 어셈블리(DLL 파일) 또는 현재 어셈블리에서 파생된 모든 클래스에 접근이 허가됨

### 🏷️ 생성자
개체를 생성하면서 무엇인가를 하고자 할 때 사용되는 메서드.
- 생성자 이름은 클래스 이름과 동일하다.
- 일반적으로 생성자는 개체를 초기화하는 데 사용됨.
- 매개변수를 달리하여 생성자를 여러 개 만들 수 있다.
- 읽기 전용 필드를 초기화 가능하다.
#### 정적 생성자 (static constructor)
- 정적 생성자는 클래스의 정적 멤버가 처음 접근될 때 단 한 번만 호출됩니다.
- 인스턴스를 생성하지 않아도 호출됩니다.
- 클래스 전체에 걸쳐 단 한 번만 실행되므로, 클래스 레벨의 초기화 작업에 사용됩니다.
- 명시적으로 호출할 수 없으며, 매개변수를 가질 수 없습니다.
#### 인스턴스 생성자 (public constructor)
- 인스턴스 생성자는 클래스의 객체를 생성할 때 호출됩니다.
- public, private, 또는 다른 접근 제한자를 가질 수 있습니다.
- 여러 개의 인스턴스 생성자를 만들어 오버로드할 수 있습니다.
#### 정적 생성자만 있을 때의 동작
인스턴스를 생성할 수 없습니다. 정적 생성자는 인스턴스와 관계없이 클래스 레벨에서 단 한 번만 호출되므로, 인스턴스 생성자가 없으면 객체를 생성할 수 없습니다.
#### 생성자 포워딩
this() 생성자를 사용하면 생성자를 포워딩(forwarding)하여 다른 생성자에 값을 전달하기 좋다.

```cs
> class Money
. {
.     public Money() : this(1000) { }
.     public Money(int money) => Console.WriteLine("Money : {0:#,###}", money);
. }
> var basic = new Money();
Money : 1,000
> var bonus = new Money(2000);
Money : 2,000
```

기본 생성자에 있는 `this(1000)`가 인자 있는 다른 생성자를 호출하는 예시.
#### 생성자를 사용하여 읽기 전용 필드 초기화
필드를 정의할 때 readonly 키워드를 붙여서 읽기 전용 필드를 만들 수 있다.
읽기 전용 필드는 클래스의 생성자로만 초기화가 가능하다.

상수는 선언과 동시에 반드시 초기화해야 에러가 발생하지 않지만,
읽기 전용 필드는 선언과 동시에 초기화도 가능하고 선언한 후 생성자로 초기화할 수도 있다.

### 🏷️ 소멸자
닷넷의 가비지 콜렉터에서 클래스의 인스턴스를 사용한 후 최종 정리할 때 실행되는 클래스에서 가장 늦게 호출되는 메서드이다.
클래스 이름과 동일한 메서드로 앞에 `~` 붙여서 만든다.

### 🏷️ 프로퍼티
```cs
class Car
{
	public string Name { get; set; }
}
```
클래스의 필드에 접근하거나 수정하는 방식을 정의하는 메서드

### 🏷️ 상속 가능한 접근 제한자
C#에서는 접근 제한자가 메서드의 상속 및 재정의 가능성에 영향을 줍니다:
- **`protected` 또는 `public`으로 선언된 메서드**만 자식 클래스에서 접근할 수 있습니다.
- 만약 메서드가 `private`로 선언되면 자식 클래스에서 접근하거나 재정의할 수 없습니다.

### 🏷️ 대리자 (delegate)

delegate는 함수 포인터다. 
메서드의 실행을 동적으로 결정할 때 사용할 수 있다.
콜백 함수를 만들 때 유용하게 사용된다.
여러 메서드를 등록해놓고 묶어서 사용할 수 있다. 
반환값은 마지막 메서드의 반환값을 사용한다.
메모리 누수를 방지하기 위해 사용이 끝났디면 반드시 -=로 참조를 해지해야 한다.

이벤트는 메서드 등록과 해지만 가능하고 직접 호출은 불가능한 delegate이다.


## 📌 자료형
---
### 🏷️ 기본 자료형 모음

| 데이터 형식 | 설명                                   |
| ------ | ------------------------------------ |
| int    | 정수형 데이터를 저장. 더 큰 정수는 long을 사용.       |
| string | 문자열 데이터를 저장.                         |
| bool   | 참 값 거짓 값 저장.                         |
| double | 실수형 데이터 저장. double, float 둘 다 실수 저장. |
| object | C#에서 사용하는 모든 형식의 데이터를 저장.            |
### 🏷️ 자료형 변환

| 메서드                | 대체             | 설명                        |
| ------------------ | -------------- | ------------------------- |
| Convert.ToString() |                | 숫자 데이터 형식을 문자열로 변경        |
| Convert.ToInt32()  | int.Parse()    | 숫자 데이터 형식을 정수 형식으로 변경     |
| Convert.ToDouble() | double.Parse() | 숫자 데이터 형식을 실수 형식으로 변경     |
| Convert.ToChar()   |                | 입력받은 숫자 또는 문자열 하나를 문자로 변경 |
데이터 형식 변환은 괄호 기호 이외에 Convert 클래스의 주요 메서드도 사용할 수 있다.

```C#
Convert.ToString(숫자, 2);
```
Convert 클래스의 ToString() 메서드는 특정 숫자의 값을 문자열로 변환할 수 있다. 정수를 이진수 문자열로 얻고 싶다면 위와 같은 형태로 두 번째 옵션에 이진수를 나타내는 2를 지정한다.

```C#
Convert.ToString(숫자, 2).PadLeft(8,'0');
```
비트 연산식을 이해하기 편하게 여덟 자리로 잡고, PadLeft() 메서드를 사용해서 8칸을 기준으로 이진수 문자열을 출력한다.

```c#
Convert.ToString(value, base); // base는 변환할 때 사용할 수치 체계
Convert.ToInt32(value, fromBase); // fromBase는 입력값의 현재 진법
```
int는 변환할 때 사용하는 진법이 정해져 있으니 입력값의 현재 진법을 알아야 하고,
string은 값을 어떤 진법으로 바꿀지 정해야 한다.

### 🏷️ const : 상수 선언
```C#
const int MAX = 100;
```

const로 선언하면 값 못바꾸고, 선언과 동시에 초기화해야 함.

### 🏷️ float
```C#
float num = 99.99f;
```
float 키워드로 실수 데이터를 직접 입력할 때는 대문자 F 또는 소문자 f를 접미사로 사용하여 대입해야 한다. 접미사를 사용하지  않으면 실수 값을 기본적으로 double 형식으로 인식하여 float 형식 변수에 담을 수 없다.

### 🏷️ var : 아무거나 넣어도 됨
```C#
var number = 1234;
```
C# 컴파일러는 **var**로 선언된 변수에 저장되는 값을 자동으로 추론해서 적당한 형식으로 변환한다. 이를 형식 추론(type inference)이라고 한다.

### 🏷️ 배열
```cs
int[] oneArray; // 1차원 배열 선언
int[,] twoArray; // 2차원 배열 선언
int[,,] threeArray; // 3차원 배열 선언
```

배열 선언

```cs
oneArray = new int[2] {1,2};
twoArray = new int[2,2] {{1,2},{3,4}};
```

배열 초기화
선언과 동시에 초기화하면 new 자료형 빼먹어도 된다
#### Rank, Length, GetLength()
```cs
arr.Rank // 3차원 배열이면 3
arr.Length // 배열 길이 반환
arr.GetLength(1) // 행의 개수
arr.GetLength(2) // 열의 개수
```

#### 가변 배열
```cs
// [2][] 형태로 두 번째를 비워 두면 동적으로 자료 n개로 초기화 가능
int[][] zagArray = new int[2][];
```

### 🏷️ 리스트
```cs
List<int> oddNumbers = new List<int>()
```

```cs
List.Count // 요소 개수
List.Contains(3) // 들어있는지 확인
List.Add(3) // 요소 더하기
List.Remove(3) // 요소 지우기
List.RemoveAt(0) // 특정 인덱스에 있는 요소 지우기
List.Clear() // 리스트 지우기
```

### 🏷️ struct : 구조체
```cs
struct Point
{
    public int X;
    public int Y;
}
```
여러 자료형 변수를 하나로 묶을 수 있다

```cs
Point[] points = new Point[2];
```
구조체 배열도 만들 수 있다.

**내장 구조체 예시**
- DateTime 구조체: 시간/날짜 관련 모든 정보 제공
- TimeSpan 구조체: 시간/날짜 간격에 대한 모든 정보 제공
- Char 구조체: 문자 관련 모든 정보 제공
- Guid 구조체: 절대로 중복되지 않는 유일한 문자열을 생성

#### DateTime : 시간/날짜 정보
```cs
> DateTime.Now.Year
2019
> DateTime now = DateTime.Now;
> Console.WriteLine(now.Date);
2019-09-23 오전 12:00:00
```

#### TimeSpan : 시간/날짜 간격
```cs
class TimeSpanDemo
{
    static void Main()
    {
        // 시간 차 구하기
        TimeSpan dday = Convert.ToDateTime("2024-12-25") - DateTime.Now;
        Console.WriteLine((int)dday.TotalDays);
    }
}
```

### 🏷️ Guid
```cs
string unique = Guid.NewGuid().ToString();
```

Guid는 GUID(Globally Unique Identifier)를 출력.
GUID 값은 실행할 때마다 동일한 값을 만날 확률이 0.

### 🏷️ enum : 열거형
```cs
enum Animal { Mouse, Cow, Tiger }
```

상수로만 구분하면 어려우니까 이름을 붙여서 쓰는 느낌.
각각 Mouse: 1, Cow: 2, Tiger: 3으로 되어있다.
초기화 시키면 그 다음부터의 상수값도 바뀐다.

```cs
Animal animal = Animal.Dragon;
int num = (int)animal;
string str = animal.ToString();
```

이러면 num은 상수값, str은 Dragon이 된다.
열거형 값은 변환하는대로 변환된다.

```cs
Animal animal = Animal.Dog;

switch (animal)
{
	case Animal.Chicken:
		break;
	case Animal.Dog:
		break;
}
```

switch 문과 같이 사용하면 유용하다.

### 🏷️ TryParse() : 변환 시도하고 안되면 기본값
```cs
public static bool TryParse(string s, out DateTime result)
```

### 🏷️ GetType() : 자료형 확인
```cs
> "ABC".GetType()
[System.String]
> "ABC[0].GetType()
[System.Char]
```

### 🏷️ 자료형 기본값으로 초기화
```C#
> int i = default;
> string s = default;
> $"[{i}] [{s}]"
[0], []
```
변수를 선언하고 초기화할 때 C#에서 기본으로 제공하는 값으로 초기화하고 싶다면  default 키워드를 사용하면 된다.

### 🏷️ 제네릭
```cs
// 어떤 요소 타입도 받아들 일 수 있는
// 스택 클래스를 C# 제네릭을 이용하여 정의
class MyStack<T>
{
    T[] _elements;
    int pos = 0;

    public MyStack()
    {
        _elements = new T[100];
    }

    public void Push(T element)
    {
        _elements[++pos] = element;
    }

    public T Pop()
    {
        return _elements[pos--];
    }
}
```

https://www.csharpstudy.com/csharp/CSharp-generics.aspx

`<T>`의 T 자리에 들어간 자료형이 클래스 안에 있는 모든 T에 적용된다.

#### 제네릭 타입 제약

```cs
// T는 Value 타입
class MyClass<T> where T : struct 

// T는 Reference 타입
class MyClass<T> where T : class

// T는 디폴트 생성자를 가져야 함
class MyClass<T> where T : new() 

// T는 MyBase의 파생클래스이어야 함
class MyClass<T> where T : MyBase

// T는 IComparable 인터페이스를 가져야 함
class MyClass<T> where T : IComparable

// 좀 더 복잡한 제약들
class EmployeeList<T> where T : Employee,
   IEmployee, IComparable<T>, new()
{
}

// 복수 타입 파라미터 제약
class MyClass<T, U> 
    where T : class 
    where U : struct
{
}
```
#### Dictionary 제네릭 클래스
```cs
> var data = new Dictionary<string, string>();
> data.Add("cs", "C#");
> foreach (var item in data)
. {
.    Console.WriteLine(item.Key, item.Value);
. }
```

```cs
// cs 키가 있으면 csharp 변수에 담음
data.TryGetValue("cs", out var csharp)

// 키 값이 있는지 없는지
data.ContainsKey("json")
```

### 🏷️ Enumerable 클래스 : 특정 범위의 정수 컬렉션 만들기
```cs
> Enumerable.Range(1,10)
RangeIterator { 1,2,3,4,5,6,7,8,9,10 }
> Enumerable.Repeat(100,5)
RepeatIterator { 100,100,100,100,100 }
```

### 🏷️ `Nullable<T>` 형식 : 값형 변수에도 null 할당 가능

값형 변수에는 원래 null 할당 못하고 에러 나는데, 할당할 수 있게 바꿔주는 거.
줄여서 표현하면 bool?, int?처럼 데이터 형식 뒤에 ?(물음표) 기호 붙이면 됨.
(? 연산자와는 다르다)

**주요 멤버**
- HasValue: 값이 있으면 true, null 값이면 false
- Value: 값 반환
- GetValueOrDefulat: 값 또는 기본값 반환



## 📌 문법
---

### 🏷️ 변수 선언 방식
```cs
int a, b, c; // 데이터 형식 동일한 변수 여러개 한꺼번에 선언
int a = 10, b = 20, c = 30;
a = b = c = 10; // 변수 여러개 동일한 값으로 초기화
```

### 🏷️ 전위 연산자, 후위 연산자
| 구분                 | 설명                                                 | 예            |
| ------------------ | -------------------------------------------------- | ------------ |
| 전위(prefix) 증감 연산자  | 정수형 변수 앞에 연산자가 위치하여 변수 값을 미리 증감한 후 나머지 연산을 수행      | ++a;<br>--b; |
| 후위(postfix) 증감 연산자 | 정수형 변수 뒤에 연산자가 위치하여 연산식(대입)을 먼저 실행한 후 나중에 변수 값을 증감 | a++;<br>b--; ||
```C#
a = a + 1;
a += 1;
++a; // 세 개의 구문은 모두 기능이 동일하다.
```

```C#
> int i = 3;
int j = ++i; // 전위 연산자는 해당 라인에서 실행 우선 순위가 가장 높음

> int i = 3;
int j = i++; // 후위 연산자는 해당 라인에서 대입 연산자보다 우선순위가 낮음
```

### 🏷️ 삼항 연산자
```C#
조건식 ? 식1 : 식2; // 참이면 식1이 실행, 거짓이면 식2가 실행
조건식 ? 값1 : 값2; // 참이면 값1, 거짓이면 값21
```

### 🏷️ 제어문 종류 : if, while, goto 등

| 제어문 | 종류                                                                                                                                    |
| --- | ------------------------------------------------------------------------------------------------------------------------------------- |
| 조건문 | if 문 : 조건 하나 비교<br>else 문 : 조건 분기<br>switch 문 : 다양한 조건                                                                                |
| 반복문 | for 문 : 구간 반복<br>do 문 : 선행 반복<br>while 문 : 조건 반복<br>foreach 문 : 배열 반복                                                                 |
| 기타  | break 문 : 반복문 내에서 반복 중지<br>continue 문 : 반복문 내에서 그다음 반복문 이동<br>goto 문 : C#에서 자주 사용하진 않지만, <br>레이블(레이블 이름과 콜론(:)으로 만듦)로 지정된 곳으로 직접 이동시킴 |
### 🏷️ 조건문
#### Switch 문
```c#
switch(표현식)
{
	case 값1: 실행문1; break;
	case 값2: 실행문2; break;
	...
	case 값n: 실행문n; break;
	default: 실행문; break;
}
```

표현식의 결괏값이 '값1'이면 '실행문1' 수행. 
case 레이블에는 상수(값)가 들어오고, default 레이블은 생략 가능.

### 🏷️ 반복문
#### for문
```cs
for(초기식; 조건식; 증감식)
{
	실행문;
}
```

#### do while
```cs
do
{
	실행문;
} while (조건식);
```

문장을 한 번 실행 후 조건을 따진다

#### foreach
```cs
foreach(데이터형식 항목 in 항목들)
{
	문장; //변수에 들어 있는 값을 사용하는 문장이 온다
	
}
```

컬렉션 형식에서 데이터를 하나씩 꺼내면서 반복

### 🏷️ 기타 제어문
#### goto
```cs
if (chapter == 1)
	goto Chapter1;
else
	goto Chapter2;

Chapter1:
Console.WriteLine("1장");
Chapter2:
Console.WriteLine("2장");
```

특정 레이블로 이동하는 기능

### 🏷️ 문자열 입력

- Console.ReadLine(): 콘솔에서 한 줄을 입력받는다.
- Console.Read(): 콘솔에서 한 문자를 정수로 입력받는다.
- Console.ReadKey(): 콘솔에서 다음 문자나 사용자가 누른 기능 키를 가져온다.

```C#
Console.WriteLine(Console.ReadLine()) // 콘솔에서 입력한 값을 그대로 출력

string num = Console.ReadLine();
Console.WriteLine(num); // 콘솔에서 입력한 값을 변수에 저장 후 출력
```

```C#
int x = Console.Read();
Console.WriteLine(x); // A를 입력했다면 A에 해당하는 정수 값 65 출력
Console.WriteLine(Convert.ToChar(x)); // 65에 해당하는 유니코드 문자 출력
```
Console.Read() 메서드를 사용하면 콘솔에서 문자를 하나만 입력받을 수 있음. 입력 값은 우리가 입력한 값과 다르게 문자에 해당하는 정수로 반환됨. 정수에 해당하는 문자를 출력할 때는 Convert.ToChar() 메서드 사용.

### 🏷️ Console.WriteLine() : 명령줄 출력
```cs
Console.WriteLine() // 명령 프롬프트에서 한 줄씩 출력
Console.Write() // 자동으로 줄 바꿈 하지 않고 출력
```

### 🏷️ ?. 연산자 : null 체크하며 멤버나 메서드 접근
```cs
ListNode l1 = null;
Console.WriteLine(l1?.next); // 출력: null (예외 발생하지 않음)

ListNode l2 = new ListNode(1);
l2.prev = l3;
Console.WriteLine(l2?.prev); // 출력: l3 (l2.next는 null)
```

null이면 null이고, null 아니면 멤버 접근해줌

이 연산자는 객체가 `null`인지 확인한 다음, 
안전하게 멤버 또는 메서드에 접근하도록 도와준다.
nullref 피할 수 있음.

**!주의: `Nullable<T>` 자료형과는 다르다.**

### 🏷️ ?? 연산자 : 왼쪽 항 null이면 반환, 아니면 오른쪽 반환
```cs
> nullValue = null;
> message = nullValue ?? "null일 경우 반환"
"null일 경우 반환"
```

```cs
> int? x = null;
> int y = x ?? default(int);
```
? 연산자와 default 키워드를 함께 사용한 예제.

```cs
> List<string> list = null;
> num = list?.Count ?? 0;
```
`list?.Count ?? 0` 형태의 코드 익히면 좋다.

### 🏷️ 튜플 리터럴
```C#
> var t = (100, 200);
> Console.WriteLine(t.Item1);
100
> Console.WriteLine(t.Item2);
200
```

 var 키워드로 변수를 선언한 후 괄호에 콤마를 구분해서 숫자 데이터를 넣으면 자동으로 t.Item1, t.Item2의 형태로 값이 저장되어 그 값을 사용할 수 있다.
 
```C#
> var (x, y) = (300, 400);
> Console.WriteLine($"{x}, {y}");
300, 400
```

자동 생성되는 형태를 사용하지 않고 변수 여러 개를 괄호 안에 선언하여 사용할 수 있다.

### 🏷️ nameof() : 클래스, 메서드 이름을 문자열로 가져오기
```cs
> nameof(System)
"System"
> nameof(Console.WriteLine)
"WriteLine"
```
속성 이름도 문자열로 가져올 수 있다.

###  🏷️ throw : 예외 발생시키기
```cs
void Divide(int a, int b)
{
    if (b == 0)
    {
        throw new DivideByZeroException("0으로 나눌 수 없습니다.");
    }
    Console.WriteLine(a / b);
}
```
`throw`를 사용하여 특정 조건에서 새로운 예외를 발생시킬 수 있습니다.

```cs
try
{
    int result = int.Parse("abc"); // 형식 오류 발생
}
catch (FormatException ex)
{
    Console.WriteLine("예외를 기록하고 다시 던짐.");
    throw; // 원래 예외를 재발생
}

```
`throw`를 사용하여 현재 발생한 예외를 다시 던질 수 있습니다. 
이를 통해 예외 처리를 상위 호출 스택에 전달할 수 있습니다.

#### throw와 throw ex의 차이
```cs
catch (Exception ex)
{
    throw; // 원래 예외를 유지하고 상위로 전달
}
```

- 현재 예외의 원래 호출 스택 정보를 유지합니다.
- 디버깅 시 예외가 발생한 정확한 위치를 추적할 수 있습니다.

```cs
catch (Exception ex)
{
    throw ex; // 호출 스택 정보가 덮어써짐
}
```

- 예외 객체를 새로 던지면서 원래 호출 스택 정보를 덮어씁니다.
- 디버깅 시 원래 예외가 발생한 위치를 알기 어렵게 만듭니다.

### 🏷️ 내장 클래스

- String 클래스: 문자열 처리와 관련한 속성과 메서드 제공
- StringBuilder 클래스: 대용량 문자열 처리와 관련된 속성 및 메서드 제공
- Array 클래스: 배열과 관련된 주요 속성 및 메서드 제공
- Environment 클래스: 프로그램 종료, 시스템 폴더, 닷넷 기준 버전, 운영 체제 버전, 컴퓨터 이름, 사용자 이름, 현재 폴더, 문서 폴더 등
- Process 클래스: Start() 메서드로 exe 파일 실행 가능
- Random 클래스: 난수 발생. 사용하려면 인스턴스 생성해야함. (UnityEngine Random이 따로 있어서 이거 쓸 일은 없을듯)
- Stopwatch 클래스: Start()와 Stop() 메서드를 이용해 프로그램 실행 시간 잴 수 있음. 출력은 timer 클래스의 TotalMilliseconds와 Seconds 같은 속성 사용하면 됨.
- regex 클래스: 정규식

#### String 클래스 메서드 정리
| **메서드**                       | **설명**                       |
| ----------------------------- | ---------------------------- |
| `Length`                      | 문자열 길이 값 반환                  |
| `ToUpper()`                   | 문자열을 모두 대문자로 변환              |
| `ToLower()`                   | 문자열을 모두 소문자로 변환              |
| `Trim()`                      | 문자열 양쪽 공백을 잘라냄               |
| `Replace(원본문자열, 대상문자열)`       | 원본 문자열을 대상 문자열로 변경           |
| `Substring(문자열인덱스, 길이)`       | 지정된 문자열 인덱스부터 길이만큼 반환        |
| `String.Concat()`             | 문자열 연결                       |
| `ToCharArray()`               | 문자열을 문자 배열로 변환               |
| `Split()`                     | 구분자를 사용하여 문자열 분리             |
| `string.IsNullOrEmpty()`      | `null` 또는 빈 값인지 확인           |
| `string.IsNullOrWhiteSpace()` | `null` 또는 빈 값 또는 공백인지 확인     |
| `IndexOf()`                   | 문자열 앞부분부터 검색해서 특정 문자 첫 등장 위치 |
| `LastIndexOf()`               | 문자열 뒷부분부터 검색해서 특정 문자 첫 등장 위치 |
| `Insert()`                    | 문자열 삽입                       |
| `Remove()`                    | 지정한 위치의 문자 또는 문자열 제거         |
| `PadLeft()`                   | 특정 문자를 왼쪽에 채움                |
| `PadRight()`                  | 특정 문자를 오른쪽에 채움               |
| `StartsWith()`                | 특정 문자열로 시작하는지 여부             |
| `EndsWith()`                  | 특정 문자열로 끝나는지 여부              |

#### StringBuilder 클래스 : 더 빠른 문자열

StringBuilder 클래스를 사용하려면 다음과 같이
```cs
> StringBuilder builder = new StringBuilder();
```
새로운 이름의 개체(인스턴스)를 생성해야 함.
출력하려면 `ToString()` 메서드로 문자열로 변환 후 사용 가능.

| **메서드**        | **설명**                 |
| -------------- | ---------------------- |
| `Append()`     | 문자열 추가                 |
| `AppendLine()` | 문자열 추가하는데 끝에 `\r\n` 있음 |

### 🏷️ LINQ

특정 형식에 원래는 없던 기능을 덧붙이는 개념으로 확장 메서드(extension method)를 제공한다.
`using System.Linq` 네임스페이스 선언하면 사용할 수 있다.

**메서드 예시**
- Sum()
- Count()
- Average()
- Max()
- Min()

- 메서드 구문: Where()같은 메서드를 사용하여 컬렉션 다루기
- 쿼리 구문: from, where, select 같은 키워드를 사용하여 쿼리 형태로 컬렉션 다루기

```cs
> numbers.Where(n => n % 2 == 0).OrderByDescending(n => n)
OrderedEnumerable<int, int> { 10,8,6,4,2 }
> (from n in numbers where n % 2 == 0 orderby n descending select n)
OrderedEnumerable<int, int> { 10,8,6,4,2 }
```

두 가지 문법으로 같은 결과를 낼 수 있다. 
쿼리 구문에 메서드를 붙일 수도 있다.

#### 화살표 함수 (람다식) : 메서드 코드 줄이기
```cs
class ArrowFunction
{
    static void Main()
    {
        Hi();
        Console.WriteLine(Multiply(3,5));
    }

    static void Hi() => Console.WriteLine("안녕하세요.");
    static void Multiply(int a, int b) => { return a * b; };
}
```

화살표 연산자 (=>) 를 사용하여 메서드 코드를 줄일 수 있다.

#### Where() 메서드 : 조건식을 만족하는 컬렉션
```cs
> int[] numbers = { 1,2,3,4,5 }
> IEnumerable<int> newNumbers = numbers.Where(number => number > 3);
```
Where() 메서드에 람다 식을 제공하여 새로운 컬렉션을 가져올 수 있다. 
(ToList() 쓰면 List로 받을 수 있음)

#### All() 메서드 : 조건식 모두 만족하는지
```cs
> bool[] completes = { true, false, true };
> completes.All(c => c == true);
false
```
All()은 조건식을 모두 만족해야 true

#### Any() 메서드 : 조건식 하나라도 만족하는지
```cs
> bool[] completes = { true, false, true };
> completes.Any(c => c == false);
true
```
Any()는 하나라도 조건식을 만족하면 true

#### Take() 메서드 : 지정한 개수만큼 데이터 가져오기
```cs
> var data = Enumerable.Range(0, 100);
> data.Take(5);
TakeIterator { 0,1,2,3,4 }
> data.Where(n => n % 2 == 0).Take(5);
TakeIterator { 0,2,4,6,8 }
```

#### Skip() : 지정한 수만큼 데이터를 제외한 컬렉션 반환
```cs
> var data = Enumerable.Range(0, 100)
> var next = data.Skip(10).Take(5); // 10개를 제외하고 5개 가져오기
> next
TakeIterator {10,11,12,13,14}
```

#### Distinct() : 중복 제거하기
```cs
> var data = Enumerable.Repeat(3,5);
> var result = data.Distinct();
> result
DistinctIterator {3}
```

#### OrderBy() : 오름차순 정렬
```cs
> string[] colors = { "Red", "Green", "Blue" };
> var sortedColors = colors.OrderBy(name => name); // Blue, Green, Red
```

#### OrderByDescending() : 내림차순 정렬
```cs
> var colors = new List<string> { "Red", "Blue", "Green" };
> var sortedColors = colors.OrderByDescending(c => c); // Red Green Blue
```

#### Single()과 SingleOrDefault() : 조건에 맞는 값을 하나 가져오기

- Single(): null 값이면 예외가 발생한다. 즉, 에러가 발생한다.
- SingleOrDefault(): 값이 없으면 null 값을 반환한다.

```cs
> string black = colors.Single(color => color == "Black"); // black 없으면 오류 남
> string black = colors.SingleOrDefault(color => color == "Black"); // black 없으면 null 반환
```

#### First()와 FirstOrDefault() : 첫 번째 요소 반환

- First(): 첫 번째 요소가 없으면 에러가 발생
- FirstOrDefault(): 첫 번째 요소가 없으면 기본값 반환

#### Select() : 특정 속성만 뽑아내거나, 데이터 형태 변환
```cs
// 점수가 80 이상인 학생의 이름만 선택
var highScorers = students
    .Where(s => s.Score >= 80)       // 필터링
    .Select(s => s.Name);            // 변환
```

Select()의 결괏값은 따로 클래스 이름이 정해지지 않은 익명 형식이기에 반드시 var과 함께 사용해야 한다.

- 단순히 조건을 적용해서 데이터를 골라낼 때는 `where()`만 사용하면 충분.
- 데이터를 변환하거나 새로운 형식으로 바꾸어야 할 때는 `select()`가 필요.

#### ForEach() : 반복문 돌리기
```cs
> var numbers = new List<int>() {10,20,30,40,50};
> numbers.Where(n => n <= 20).ToList().ForEach(n => Console.WriteLine(n));
10
20
```
for문이나 foreach문 사용 안 하고 각 요소에 대해 반복 돌릴 수 있다


### 🏷️ virtual, override : 상속 시 재정의
```cs
public class ParentClass
{
    public virtual void Greet()
    {
        Debug.Log("Hello from ParentClass");
    }
}

public class ChildClass : ParentClass
{
    public override void Greet()
    {
        Debug.Log("Hello from ChildClass");
    }
}
```

`virtual`은 부모 클래스에서 정의된 메서드를 자식 클래스에서 **선택적으로 재정의**할 수 있도록 허용합니다.
- **기본 구현**이 부모 클래스에 제공됩니다.
- 자식 클래스에서 재정의하지 않으면 부모 클래스의 구현이 사용됩니다.
- 자식 클래스에서 재정의할 때는 반드시 `override`를 사용해야 합니다.

`override`는 부모 클래스에서 정의된 **`virtual`** 또는 **`abstract`** 메서드를 **재정의**할 때 사용하는 키워드입니다.
- 부모 클래스의 메서드를 대체하거나 확장합니다.
- 반드시 부모 클래스의 메서드와 동일한 이름, 반환 형식, 매개변수를 가져야 합니다.

### 🏷️ abstract : 부모 클래스에서 구현 없는 메서드
```cs
public abstract class Animal
{
    public abstract void Speak(); // 구현 없음
}

public class Dog : Animal
{
    public override void Speak()
    {
        Debug.Log("Woof! Woof!");
    }
}

public class Cat : Animal
{
    public override void Speak()
    {
        Debug.Log("Meow!");
    }
}
```

`abstract`는 부모 클래스에서 **메서드의 이름과 시그니처만 정의**하고, **구현은 하지 않는** 키워드입니다.
- 반드시 **추상 클래스(`abstract class`)** 내부에서 사용됩니다.
- 자식 클래스에서 반드시 해당 메서드를 **구현(`override`)**해야 합니다.
- 추상 메서드는 기본 구현이 없으므로 자식 클래스에서 반드시 내용을 정의해야 합니다.




## 📌 구현
---

### 🏷️ 특정 문자열을 포함하는 컬렉션 가져오기
```cs
> var colors = new List<string> { "red", "green", "blue" };
> var newColors = colors.Where(c => c.Contains("ee")); // green
```

### 🏷️ 여러 문자열 합쳐서 출력하는 방법들

**자료 표시자**
```C# 
Console.WriteLine("{1}, {0}", "Hello", "C#");
```
프로그램 실행 결과를 화면에 출력할 때 사용하는 출력문 등에서 자리 표시자(틀) 개념을 이용해서 출력 서식을 지정할 수 있다. {n} 형태로 {0}, {1}, {2} 순서대로 자리를 만들고 그 다음에 있는 값을 차례로 넘겨받아 출력한다.

**String.Format() 메서드**
```C#
string msg = string.Format("{0}님, {1}", "백승수", "안녕하세요.")
Console.WriteLine(msg);
```
String.Format()은 Console.WriteLine() 메서드처럼 {0}, {1}, {2}, 순서대로 뒤에서 오는 문자열을 채워 문자열로 반환해 준다.

**문자열 보간법 ★ // 책 저자가 추천**
```C#
int number = 3;
string result = "홀수";
Console.WriteLine($"{number}은 {result}입니다.");
```
자리 표시자 대신 직접 특정 변수 값을 중괄호 기호로 표현할 수 있다. 이때 문자열 앞에는 $ 기호가 와야 한다.

### 🏷️ 메서드 이름 간단하게 줄여서 쓰는 방법

**using으로 별칭 지정**
```cs
using printf = System.Console.WriteLine;
```

**람다 표현식으로 간단히 지정**
```cs
var printf = (string msg) => Console.WriteLine(msg);
```

**`Action<T>` 대리자에 넣어서 사용**
```cs
Action<string> printf = Console.WriteLine;