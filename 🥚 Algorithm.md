- [[#난이도 下|난이도 下]]
	- [[#난이도 下#문자열 조합|문자열 조합]]
	- [[#난이도 下#dfs|dfs]]
	- [[#난이도 下#bfs|bfs]]
	- [[#난이도 下#시뮬레이션|시뮬레이션]]
	- [[#난이도 下#투포인터|투포인터]]
	- [[#난이도 下#이분탐색|이분탐색]]
- [[#난이도 中|난이도 中]]
	- [[#난이도 中#위상정렬|위상정렬]]
		- [[#위상정렬#1. 기초|1. 기초]]
		- [[#위상정렬#2. 경로 역추적|2. 경로 역추적]]
	- [[#난이도 中#최소 신장 트리 (MST)|최소 신장 트리 (MST)]]
	- [[#난이도 中#크루스칼|크루스칼]]
		- [[#크루스칼#1. 이행적 폐쇄 (Transitive Closure)|1. 이행적 폐쇄 (Transitive Closure)]]
		- [[#크루스칼#2. 최소 비용 (Floyd-Warshall Algorithm)|2. 최소 비용 (Floyd-Warshall Algorithm)]]
	- [[#난이도 中#프림|프림]]
	- [[#난이도 中#그리디|그리디]]
	- [[#난이도 中#백트래킹|백트래킹]]
- [[#난이도 上|난이도 上]]
	- [[#난이도 上#동적 프로그래밍|동적 프로그래밍]]
	- [[#난이도 上#트라이, KMP|트라이, KMP]]
	- [[#난이도 上#다익스트라|다익스트라]]



## template
---
### .h
```cpp
#pragma once
#include<iostream>
#include<vector>
#include<queue>

class B
{
public:
	static void Solution();
};
```

### .cpp
```cpp
#include".h"
#define INF 0x3f3f3f3f
#define fastio cin.tie(0)->sync_with_stdio(0)
using namespace std;
typedef pair<int, int> pii;

void B::Solution()
{
	fastio;
}
```


## 팁
---

- 조금 절어도 시간 많으니까 침착하게 문제 처음부터 끝까지 다 읽고 풀 것
- 내가 무슨 구현을 할 건지 적으면서 구현하기
- 띄어쓰기 없다고 꼭 string으로 안 받아도 됨. cin을 char에 넣으면 알아서 한 문자만 받음.

```cpp
#define INF 0x3f3f3f3f
```
- **16진수 0x3f3f3f3f = 약 1061109567**
- 메모리 상에서 `memset()`으로 초기화할 수 있는 가장 큰 양수 중 하나
- `int` 범위 내에서 충분히 큰 값이기 때문에 **"무한대처럼 쓰는 관례"**

```cpp
if (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;
if (visited[nx][ny]) continue;
```
상하좌우 확인할 때 if 안에 감싸지 말고 보호 구문 처리 하면 더 가독성 좋다



## 실수 
---

- 요소 인덱스가 0~N인지, 1~N까지인지 확인을 해줘야 함
- 테케가 다를 때 모든 변수와 자료구조 초기화 해줘야 함
- 문제를 대충 혹은 덜 읽고 조건 빠뜨리지 말기
- 무지성으로 인덱스 작성하지 말고 접근하는 인덱스가 무슨 의미인지 생각하기
- `using namespace std` 빼먹지 말기

- 초기화를 int max로 하면 오버플로우 발생 가능성 조심
- 최소 우선순위 큐 선언할 때 자료형 int 아니면 다른 것도 int가 아니라 바꿔줘야 함
- 분명 다른거 전부 double로 선언돼있는데도 손 나가는대로 변수를 int로 선언해버리지 말기
- push() 때문에 size()가 변하는데 캐싱한답시고 이전 size()를 그대로 사용해서 로직 오류

## 난이도 下
---
### 문자열 조합



---
### dfs




---
### bfs

- 큐의 size를 센 뒤 그만큼만 빼면 depth마다 따로 모아서 탐색할 수 있다. ([코드](https://lazyartisan.tistory.com/48))


---
### 시뮬레이션

- 시뮬레이션도 큐를 활용하면 필요한 부분만 갱신할 수 있다 ([코드](https://lazyartisan.tistory.com/50)) - 사실 문제 자체는 시뮬레이션으로 분류가 안돼있긴 함. 내가 억지로 시뮬레이션으로 풀었던 거.


---
### 투포인터


---
### 이분탐색


---


## 난이도 中
---
### 위상정렬

#### 1. 기초

사이클이 없는 단방향 그래프면 일단 위상 정렬 의심하기.

간선 하나 탐색해서 뽑아버릴 때마다 indegree 하나씩 빼주고,
indegree가 0이 되면 그제야 해당 정점에서 갈 수 있는 다음 정점을 탐색한다.

쉽게 말하여, "**들어올 수 있는 간선 다 찾았으면 다음으로 보낸다.**"

근데 재귀로 역탐색하면 해당 도착지까지 필요한 경로를 위상 정렬과 똑같이 구할 수 있음.
이렇게 하는게 더 간단. ([코드](https://lazyartisan.tistory.com/51))
모든 정점에 대해 순서를 지켜서 출력해야되는거면 역탐색 재귀 쓰면 안됨.

#### 2. 경로 역추적

경로 역추적 (임계경로 문제) : [코드](https://lazyartisan.tistory.com/52)

---
### 그래프 사이클 검출

- 유향 그래프
  - dfs 하면서 방문하면 traced true, 방문 끝나면 traced false, visited true
  - dfs 도중 visited true인 노드를 방문하면 해당 dfs 분기 끝, traced true인 노드를 방문하면 사이클 존재.
- 무향 그래프 : dfs 하면서 부모가 아닌데 또 방문하게 됐다면 사이클 존재


---
### 최소 신장 트리 (MST)



---
### 크루스칼

삼중 for문으로 모든 정점을 순회하면서  
"나 거쳐서 갈 수 있는 놈들 있어? 싹 다 갱신해봐"

가 플로이드 와샬 알고리즘이다.

#### 1. 이행적 폐쇄 (Transitive Closure)

비용 상관없이 갈 수 있느냐 없느냐만 따져보면

```
for k in range(n):  # 나 A를 거쳐서
    for i in range(n):  # B 너가
        for j in range(n):  # C로 갈 수 있니?
            if closure[i][k] and closure[k][j]:
                closure[i][j] = True
```

첫번째 for문 요소 : "나 A를 거쳐서"  
두번째 for문 요소 : "B 너가"  
세번째 for문 요소 : "C로 갈 수 있니?"

"나 A를 거쳐서, B 너가, C로 갈 수 있니?"

#### 2. 최소 비용 (Floyd-Warshall Algorithm)

최소 비용 버전으로 보면

```
for k in range(n):  # 나 A를 거쳐서 가는게
    for i in range(n):  # B 너가
        for j in range(n):  # C로 갈 때 더 빨리 가니?
            if dist[i][j] > dist[i][k] + dist[k][j]:
                dist[i][j] = dist[i][k] + dist[k][j]
```

첫번째 for문 요소 : "나 A를 거쳐서 가는게"  
두번째 for문 요소 : "B 너가"  
세번째 for문 요소 : "C로 갈 때 더 빨리 가니?"

"나 A를 거쳐서 가는게, B 너가, C로 갈 때 더 빨리 가니?"

---
### 프림



---
### 그리디



---
### 백트래킹



---

## 난이도 上
---
### 동적 프로그래밍


---
### 트라이, KMP


---
### 다익스트라

#### 1. 기초

**가중치가 있는 그래프**에서
**한 정점에서 다른 모든 정점까지의 최단 경로**를 찾는 알고리즘

[이해하기 쉬운 설명 ](https://www.youtube.com/watch?v=o9BnvwgPT-o&t=642s)

1. 매 단계마다 도달할 수 있는 정점 중에서 
   **시작점으로부터의 거리가 가장 가까운 정점**을 구하고, 
   해당 **거리를 확정**한다.

2. 거리가 확정되면 해당 정점과 **연결된 정점들의 거리도 갱신**해준다.

'dp + 그리디'로 이해하면 된다.
다익스트라는 "**항상 최소만 찾는 미친놈**"이다.

간단하게 생각하여,
매 순간마다 최소 거리인 놈들을 확정하면
최소 거리가 아닌 정보가 있을 수 없다.

![[Pasted image 20240920203431.png]]

1번째로 탐색하는 정점은 자기 자신이니까 거리가 0인게 자명.
2번째로 탐색하는 정점은 자기 자신으로부터 직접 이어진 정점이니까 최소 거리인게 자명.

3번째로 탐색하는 정점이 2번째 정점과 이어져있다면
기존에 저장돼있던 (1번 ~ 3번)의 가중치와 (2번 ~ 3번) 간선 중 최솟값을 저장하고 최소 거리 확정.

하필 (1번 ~ 3번) 과 (2번 ~ 3번)의 가중치가 너무 커서
(1번 ~ A번 ~ B번 ~ C번 ~ 3번)의 거리가 더 작을수도 있는거 아니냐고?

그러면 A번 정점을 고르지 3번 정점을 고를 수가 없음. (음수 간선이 있지 않는 한)
3번 정점을 골랐다는 말은, A번 정점은 그것보다 더 큰 가중치를 가졌다는 말임.


#### 2. 시간 복잡도

V : 정점(노드) 개수
E : 간선(엣지) 개수

**간단한 배열 사용 : O(V^2)**

방문하지 않은 정점 중 시작점에서 가장 가까운 정점을 찾기 위해 
시작점에서 모든 정점까지의 최소 거리를 일일이 탐색하면 
매번 최단 거리를 구하는 데 O(V)의 시간이 걸리고, 
이를 모든 정점에 대해 반복하면 O(V^2)

**우선순위 큐 사용 : O((E+E) log V)**

인터넷 설명들은 O((E+V) log V)로 나와있는데 구현은 O((E+E) log V)로 다르게 돼있다고 함. 

'다익스트라 알고리즘은 그리디 알고리즘이기 때문에 A->C(비용+4) 대신 A->B(비용+3)을 선택 후 B를 방문처리하게 된다. 현재는 나쁘지만 미래에는 좋은 결과를 불러오는 A->C(비용+4)&C->B(비용-5) 경로(비용-1)를 선택하지 않게 되고 올바른 해를 도출할 수 없게 된다'라는 설명은 **이 구현에서는 들어맞지 않게 된다.**

#### 3. 우선순위 큐를 이용한 다익스트라 (실제 구현)

1. 우선순위 큐에 (0, 시작점) 추가
2. 우선순위 큐에서 거리가 가장 작은 원소를 선택, 해당 거리가 최단 거리 테이블에 있는 값과 다를 경우 넘어감
3. 원소가 가리키는 정점을 V라고 할 때, V와 이웃한 정점들에 대해 최단 거리 테이블 값보다 V를 거쳐가는 것이 더 작은 값을 가질 경우 최단 거리 테이블의 값을 갱신하고 우선순위 큐에 (거리, 이웃한 정점의 번호)를 추가
4. 우선순위 큐가 빌 때까지 2, 3번 과정을 반복

결국 모든 간선에 대해 한 번씩 연산하게 됨.
우선순위 큐에 넣는 연산 포함하면 logN 곱해야됨.

이전에 최소값만 찾는 미친놈 모드에서 살짝 순해진 대신 시간 복잡도 낮아진다.
최소가 갱신되면 우선순위 큐에 정점을 추가한다. 이외엔 똑같이 행동.
